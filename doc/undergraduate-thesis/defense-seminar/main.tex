%%%%%%%%%%%%
% Preamble %
%%%%%%%%%%%%

\documentclass
  [ aspectratio=169,
    english,
    hyperref={citecolor=blue,colorlinks=true,linkcolor=blue,urlcolor=blue},
    brazil]
  {beamer}

%%%%%%%%%%%%%
%% Packages %
%%%%%%%%%%%%%

%%%%%%%%%%%%%%
%%% Encoding %
%%%%%%%%%%%%%%

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

%%%%%%%%%%%%%%%%%%%
%%% Miscellaneous %
%%%%%%%%%%%%%%%%%%%

\usepackage[portuguese]{babel}
\usepackage[backend=biber,indent,style=abnt]{biblatex}
\usepackage[listings,minted,skins,xparse]{tcolorbox}
\usepackage{csquotes}
\usepackage{palatino}
\usepackage{xspace}

%%%%%%%%%%%%
%% Aliases %
%%%%%%%%%%%%

\newcommand{\treesitter}{\textit{Tree-Sitter}\xspace}
\newcommand{\witchcooking}{\textit{Witch Cooking}\xspace}
\newcommand{\worktitle}{\witchcooking}
\newcommand
  {\worksubtitle}
  {%
    Formatação Multilíngue e Personalizada de Código-Fonte via o Sistema
    \treesitter}

%%%%%%%%%%%%%%%%%%
%% Configuration %
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%
%%% Beamer %
%%%%%%%%%%%%

\setbeamertemplate{frametitle continuation}{}
\setbeamertemplate{headline}{}
\setbeamertemplate{navigation symbols}{}

%%%%%%%%%%%%%%%%%%
%%% Bibliography %
%%%%%%%%%%%%%%%%%%

\addbibresource{../references.bib}

%%%%%%%%%%%%%%%%%%%
%%% Code Snippets %
%%%%%%%%%%%%%%%%%%%

\renewcommand{\theFancyVerbLine}{\ttfamily\arabic{FancyVerbLine}}

\definecolor{codehighlight}{RGB}{240,240,170}
\newcommand{\hi}[1]{\colorbox{codehighlight}{#1}}
\setminted{highlightcolor={codehighlight},spacecolor=gray!50}

\NewTotalTCBox
  {\codesnippetinline}
  {O{text}vO{}}
  { bottom=0pt,
    enhanced,
    frame hidden,
    left=0pt,
    on line,
    right=0pt,
    sharp corners,
    top=0pt}
  {\mintinline[#3]{#1}{#2}}%

%%%%%%%%%%%%
%%% Colors %
%%%%%%%%%%%%

\definecolor{blue}{RGB}{41,5,195}

%%%%%%%%%%
%%% Font %
%%%%%%%%%%

\usefonttheme{professionalfonts}
\renewcommand\familydefault{\rmdefault}

%%%%%%%%%%%%%%%%
%%% Title Page %
%%%%%%%%%%%%%%%%

\title{\worktitle}
\subtitle{\worksubtitle}
\author{Átila Gama Silva}
\date{\today}
\titlegraphic{\includegraphics[height=1cm]{../ifba-irece-logo.png}}

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\begin{document}
  %%%%%%%%%%%%%%
  % Title Page %
  %%%%%%%%%%%%%%

  \begin{frame}\titlepage\end{frame}

  %%%%%%%%%%%%%%%
  % Motivations %
  %%%%%%%%%%%%%%%

  \begin{frame}{Motivações}
    \begin{itemize}
      \item As motivações surgiram das dificuldades ao estudar estilos de
            formatação de código-fonte em diversas linguagens de programação
            \begin{itemize}
              \item Durante a análise dos estilos convencionais de formatação
                    \begin{itemize}
                      \item Era imprescindível recorrer a diferentes
                            \textit{prettyprinters}
                      \item Cada um com suas próprias configurações e níveis de
                            suporte para esses estilos
                    \end{itemize}
              \item Durante a análise dos estilos não convencionais
                    \begin{itemize}
                      \item A aplicação manual era inevitável, consumindo
                            consideravelmente tempo e esforço
                    \end{itemize}
            \end{itemize}
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%%
  % Problems %
  %%%%%%%%%%%%

  \begin{frame}{Problemas}
    \begin{itemize}
      \item De modo geral, os formatadores de código-fonte
            \begin{itemize}
              \item São restritos a uma linguagem específica ou a uma família
                    de linguagens de programação
              \item Oferecem uma quantidade limitada de configurações de
                    estilização
              \item Proporcionam pouca personalização
            \end{itemize}
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%%%%%%%%%%%%
  % General Objectives %
  %%%%%%%%%%%%%%%%%%%%%%

  \begin{frame}{Objetivos Gerais}
    \begin{itemize}
      \item Desenvolver um software de linha de comando --- de natureza
            prototípica --- para a formatação de código-fonte, tendo como
            objetivos
            \begin{itemize}
              \item Abranger uma gama de linguagens de programação
              \item Proporcionar a formatação personalizada via a linguagem de
                    consulta do \treesitter
            \end{itemize}
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%%%%%%%%%%%%%
  % Specific Objectives %
  %%%%%%%%%%%%%%%%%%%%%%%

  \begin{frame}[fragile]{Objetivos Específicos}
    \begin{itemize}
      \item Desenvolver um algoritmo de formatação fundamentado no \treesitter
      \item Definir configurações de estilização para o predicado
            \codesnippetinline{set!}, nativo da linguagem de consulta do
            \treesitter
      \item Estender os predicados embutidos da linguagem de consulta,
            proporcionando predicados basais para a formatação
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%%%%%%%%%%%%%
  % The Code Formatting %
  %%%%%%%%%%%%%%%%%%%%%%%

  \begin{frame}{A Formatação de Código-Fonte}
    \begin{itemize}
      \item Desde os primórdios da computação, métodos foram desenvolvidos para
            garantir que a saída impressa fosse formatada de maneira
            esteticamente agradável
            \apud{harris-1956-keyboard}[1]{yelland-2015-new}
      \item Esses métodos ganharam popularidade sob o termo
            \textit{``prettyprinting''}
      \item No desenvolvimento de software, o \textit{prettyprinting} é
            conhecido como formatação de código-fonte
    \end{itemize}
  \end{frame}

  \begin{frame}{A Formatação de Código-Fonte}
    \begin{itemize}
      \item Durante as décadas de 60 e 70, a linguagem de programação LISP
            proporcionou condições favoráveis para o avanço da formatação de
            código \cite[2]{yelland-2015-new}
      \item Em 1967, Bill Gosper desenvolveu o \textit{GRINDEF}: considerado o
            primeiro \textit{prettyprinter} a mensurar o tamanho das linhas e
            ter ciência de sua localização no arquivo
            \cites{gosper-2023-twubblesome}{griesemer-2022-cultural}
      \item Posteriormente, \textcite{oppen-1980-prettyprinting} apresentou um
            algoritmo inovador capaz de formatar código-fonte derivado de
            qualquer linguagem de programação
            \begin{itemize}
              \item O algoritmo necessitava que o código fosse anotado --- por
                    uma ferramenta intermediária --- com espaços em branco e
                    delimitadores especiais para marcar o início e fim de
                    blocos
            \end{itemize}
    \end{itemize}
  \end{frame}

  \begin{frame}{A Formatação de Código-Fonte}
    \begin{itemize}
      \item Recentemente, \textcite{yelland-2015-new} descreveu um algoritmo
            que visa otimizar o layout do código em relação a uma noção
            intuitiva de custo de layout
            \begin{itemize}
              \item Notavelmente, entre as abstrações de programação
                    empregadas para facilitar sua aplicação em diversas
                    linguagens e políticas de layout de código,
                    destacam-se os \textit{combinators}: funções geradoras que
                    descrevem layouts alternativos para o código-fonte
            \end{itemize}
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%%%%%%%%%%%%%%%%
  % The Tree-Sitter System %
  %%%%%%%%%%%%%%%%%%%%%%%%%%

  \begin{frame}{O Sitema \treesitter}
    \begin{itemize}
      \item O \treesitter \cite{tree-sitter-2023-tree} é um sistema multilíngue
            de análise sintática para ferramentas de programação, desenvolvido
            como uma tentativa de solucionar problemas presentes nas
            ferramentas de análise sintática da época, tendo como objetivos
            \begin{itemize}
              \item Produzir árvores de sintaxe a partir da análise de códigos
                    escritos em várias linguagens
              \item Implementar a análise incremental, permitindo a atualização
                    da árvore de sintaxe em tempo real
              \item Expor através da árvore de sintaxe os nós representando
                    suas construções gramaticais no código (e.g., classes,
                    funções, declarações, etc.)
              \item Ser livre de dependências, assim beneficiando sua adoção e
                    aplicabilidade
            \end{itemize}
    \end{itemize}
  \end{frame}

  \begin{frame}{O Sitema \treesitter}
    \begin{itemize}
      \item Além disso, o \treesitter oferece uma pequena linguagem de
            consulta declarativa que é capaz de expressar padrões da árvore
            sintática por meio de \textit{S-expressions} e buscar
            correspondências
      \item Essa linguagem suporta operadores que permitem
            \begin{itemize}
              \item A captura de nós
              \item A quantificação de nós, análoga às expressões regulares
              \item O agrupamento de nós
              \item As alternâncias de nós
              \item O uso de \textit{wildcards}
              \item A ordenação de nós
            \end{itemize}
    \end{itemize}
  \end{frame}

  \begin{frame}{O Sitema \treesitter}
    \begin{itemize}
      \item Adicionalmente, a linguagem de consulta permite o uso de predicados
            --- funções arbitrárias geralmente utilizadas para filtrar nós ou
            realizar verificações mais complexas durante a busca de padrões
            ---, sejam eles \textit{builtins} ou estendidos por meio de uma API
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%%%
  % Materials %
  %%%%%%%%%%%%%

  \begin{frame}{Materiais}
    \begin{itemize}
      \item O \witchcooking foi desenvolvido com base
            \begin{itemize}
              \item No ecossistema Rust, composto
                    \begin{itemize}
                      \item Pela linguagem de programação Rust
                            \cite{rust-2023-rust}
                      \item Pelo gerenciador de pacotes \textit{Cargo}
                            \cite{rust-2023-cargo}
                      \item Pelo servidor de linguagem \textit{rust-analyzer}
                            \cite{rust-analyzer-2023-rust}
                    \end{itemize}
              \item No sistema/biblioteca \treesitter
                    \cite{tree-sitter-2023-tree}
              \item No ecossistema Neovim, composto
                    \begin{itemize}
                      \item Pelo editor de texto \textit{Neovim}
                            \cite{neovim-2023-hyperextensible}
                      \item Pelas configurações personalizadas
                            \cite{silva-2023-uma}
                      \item Pelo plugin \textit{nvim-treesitter}
                            \cite{nvim-treesitter-2023-nvim}
                      \item Pelo plugin \textit{playground}
                            \cite{nvim-treesitter-2023-playground}
                    \end{itemize}
            \end{itemize}
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%
  % Methods %
  %%%%%%%%%%%

  \begin{frame}{Métodos}
    \begin{itemize}
      \item Foi realizado uma pesquisa experimental com o objetivo de explorar
            a aplicação do \treesitter como base para o algoritmo de formatação
            de código-fonte
      \item Similarmente, foram integrados elementos de um estudo de caso com o
            propósito de analisar a eficácia do software desenvolvido
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%%%%%%
  % Bibliography %
  %%%%%%%%%%%%%%%%

  \begin{frame}[allowframebreaks]{Referências}\printbibliography\end{frame}
\end{document}