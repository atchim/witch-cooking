%%%%%%%%%%%%
% Preamble %
%%%%%%%%%%%%

\documentclass
  [ aspectratio=169,
    english,
    hyperref={citecolor=blue,colorlinks=true,linkcolor=blue,urlcolor=blue},
    brazil]
  {beamer}

%%%%%%%%%%%%%
%% Packages %
%%%%%%%%%%%%%

%%%%%%%%%%%%%%
%%% Encoding %
%%%%%%%%%%%%%%

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

%%%%%%%%%%%%%%%%%%%
%%% Miscellaneous %
%%%%%%%%%%%%%%%%%%%

\usepackage[portuguese]{babel}
\usepackage[backend=biber,indent,style=abnt]{biblatex}
\usepackage[listings,minted,skins,xparse]{tcolorbox}
\usepackage{csquotes}
\usepackage{palatino}
\usepackage{tikz}
\usepackage{xspace}

%%%%%%%%%%%%
%% Aliases %
%%%%%%%%%%%%

\newcommand{\treesitter}{\textit{Tree-Sitter}\xspace}
\newcommand{\witchcooking}{\textit{Witch Cooking}\xspace}
\newcommand{\worktitle}{\witchcooking}
\newcommand
  {\worksubtitle}
  {%
    Formatação Multilíngue e Personalizada de Código-Fonte via o Sistema
    \treesitter}

%%%%%%%%%%%%%%%%%%
%% Configuration %
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%
%%% Beamer %
%%%%%%%%%%%%

\setbeamertemplate{frametitle continuation}{}
\setbeamertemplate{headline}{}
\setbeamertemplate{navigation symbols}{}

%%%%%%%%%%%%%%%%%%
%%% Bibliography %
%%%%%%%%%%%%%%%%%%

\addbibresource{../references.bib}

%%%%%%%%%%%%%%%%%%%
%%% Code Snippets %
%%%%%%%%%%%%%%%%%%%

\renewcommand{\theFancyVerbLine}{\ttfamily\arabic{FancyVerbLine}}

\definecolor{codehighlight}{RGB}{240,240,170}
\newcommand{\hi}[1]{\colorbox{codehighlight}{#1}}
\setminted{highlightcolor={codehighlight},spacecolor=gray!50}

\NewTotalTCBox
  {\codesnippetinline}
  {O{text}vO{}}
  { bottom=0pt,
    enhanced,
    frame hidden,
    left=0pt,
    on line,
    right=0pt,
    sharp corners,
    top=0pt}
  {\mintinline[#3]{#1}{#2}}%

\NewTCBListing
  {codesnippet}
  {sO{text}m!O{}!O{}}
  { enhanced,
    center title,
    coltitle=black,
    fonttitle=\scriptsize,
    frame hidden,
    listing engine=minted,
    listing only,
    minted language=#2,
    minted options=
      { autogobble,
        breakanywhere,
        breakanywheresymbolpre={},
        breakautoindent=false,
        breaklines,
        breaksymbol={},
        fontsize=\scriptsize,
        linenos,
        xleftmargin=\IfBooleanTF{#1}{1.5}{1}em,
        #4},
    nobeforeafter,
    overlay=
      {%
        \begin{tcbclipinterior}
          \fill[gray!25]
          (frame.south west)
          rectangle
          ([xshift=\IfBooleanTF{#1}{2.5}{2}em]frame.north west);
        \end{tcbclipinterior}},
    sharp corners,
    title={#3},
    #5}

%%%%%%%%%%%%
%%% Colors %
%%%%%%%%%%%%

\definecolor{blue}{RGB}{41,5,195}

%%%%%%%%%%
%%% Font %
%%%%%%%%%%

\usefonttheme{professionalfonts}
\renewcommand\familydefault{\rmdefault}

%%%%%%%%%%
%%% TikZ %
%%%%%%%%%%

\usetikzlibrary{calc,decorations.pathmorphing,positioning}

%%%%%%%%%%%%%%%%
%%% Title Page %
%%%%%%%%%%%%%%%%

\title{\worktitle}
\subtitle{\worksubtitle}
\author{Átila Gama Silva}
\date{\today}
\titlegraphic{\includegraphics[height=1cm]{../ifba-irece-logo.png}}

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\begin{document}
  %%%%%%%%%%%
  % Lengths %
  %%%%%%%%%%%

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %% Text Width Plus Two em Parts %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \newlength{\halftextwidthplustwoempart}
  \setlength{\halftextwidthplustwoempart}{.5\textwidth + 2em}
  \newlength{\halftextwidthplustwoemcounterpart}
  \setlength{\halftextwidthplustwoemcounterpart}{.5\textwidth - 3em}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %% Text Width Plus Five em Parts %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \newlength{\halftextwidthplusfiveempart}
  \setlength{\halftextwidthplusfiveempart}{.5\textwidth + 5em}
  \newlength{\halftextwidthplusfiveemcounterpart}
  \setlength{\halftextwidthplusfiveemcounterpart}{.5\textwidth - 6em}

  %%%%%%%%%%%%%%
  % Title Page %
  %%%%%%%%%%%%%%

  \begin{frame}\titlepage\end{frame}

  %%%%%%%%%%%%%%%
  % Motivations %
  %%%%%%%%%%%%%%%

  \begin{frame}{Motivações}
    \begin{itemize}
      \item As motivações surgiram das dificuldades ao estudar estilos de
            formatação de código-fonte em diversas linguagens de programação
            \begin{itemize}
              \item Durante a análise dos estilos convencionais de formatação
                    \begin{itemize}
                      \item Era imprescindível recorrer a diferentes
                            \textit{prettyprinters}
                      \item Cada um com suas próprias configurações e níveis de
                            suporte para esses estilos
                    \end{itemize}
              \item Durante a análise dos estilos não convencionais
                    \begin{itemize}
                      \item A aplicação manual era inevitável, consumindo
                            consideravelmente tempo e esforço
                    \end{itemize}
            \end{itemize}
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%%
  % Problems %
  %%%%%%%%%%%%

  \begin{frame}{Problemas}
    \begin{itemize}
      \item De modo geral, os formatadores de código-fonte
            \begin{itemize}
              \item São restritos a uma linguagem específica ou a uma família
                    de linguagens de programação
              \item Oferecem uma quantidade limitada de configurações de
                    estilização
              \item Proporcionam pouca personalização
            \end{itemize}
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%%%%%%%%%%%%
  % General Objectives %
  %%%%%%%%%%%%%%%%%%%%%%

  \begin{frame}{Objetivos Gerais}
    \begin{itemize}
      \item Desenvolver um software de linha de comando --- de natureza
            prototípica --- para a formatação de código-fonte, tendo como
            objetivos
            \begin{itemize}
              \item Abranger uma gama de linguagens de programação
              \item Proporcionar a formatação personalizada via a linguagem de
                    consulta do \treesitter
            \end{itemize}
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%%%%%%%%%%%%%
  % Specific Objectives %
  %%%%%%%%%%%%%%%%%%%%%%%

  \begin{frame}[fragile]{Objetivos Específicos}
    \begin{itemize}
      \item Desenvolver um algoritmo de formatação fundamentado no \treesitter
      \item Definir configurações de estilização para o predicado
            \codesnippetinline{set!}, nativo da linguagem de consulta do
            \treesitter
      \item Estender os predicados embutidos da linguagem de consulta,
            proporcionando predicados basais para a formatação
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%%%%%%%%%%%%%
  % The Code Formatting %
  %%%%%%%%%%%%%%%%%%%%%%%

  \begin{frame}{A Formatação de Código-Fonte}
    \begin{itemize}
      \item Desde os primórdios da computação, métodos foram desenvolvidos para
            garantir que a saída impressa fosse formatada de maneira
            esteticamente agradável
            \apud{harris-1956-keyboard}[1]{yelland-2015-new}
      \item Esses métodos ganharam popularidade sob o termo
            \textit{``prettyprinting''}
      \item No desenvolvimento de software, o \textit{prettyprinting} é
            conhecido como formatação de código-fonte
    \end{itemize}
  \end{frame}

  \begin{frame}{A Formatação de Código-Fonte}
    \begin{itemize}
      \item Durante as décadas de 60 e 70, a linguagem de programação LISP
            proporcionou condições favoráveis para o avanço da formatação de
            código \cite[2]{yelland-2015-new}
      \item Em 1967, Bill Gosper desenvolveu o \textit{GRINDEF}: considerado o
            primeiro \textit{prettyprinter} a mensurar o tamanho das linhas e
            ter ciência de sua localização no arquivo
            \cites{gosper-2023-twubblesome}{griesemer-2022-cultural}
      \item Posteriormente, \textcite{oppen-1980-prettyprinting} apresentou um
            algoritmo inovador capaz de formatar código-fonte derivado de
            qualquer linguagem de programação
            \begin{itemize}
              \item O algoritmo necessitava que o código fosse anotado --- por
                    uma ferramenta intermediária --- com espaços em branco e
                    delimitadores especiais para marcar o início e fim de
                    blocos
            \end{itemize}
    \end{itemize}
  \end{frame}

  \begin{frame}{A Formatação de Código-Fonte}
    \begin{itemize}
      \item Recentemente, \textcite{yelland-2015-new} descreveu um algoritmo
            que visa otimizar o layout do código em relação a uma noção
            intuitiva de custo de layout
            \begin{itemize}
              \item Notavelmente, entre as abstrações de programação
                    empregadas para facilitar sua aplicação em diversas
                    linguagens e políticas de layout de código,
                    destacam-se os \textit{combinators}: funções geradoras que
                    descrevem layouts alternativos para o código-fonte
            \end{itemize}
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%%%%%%%%%%%%%%%%
  % The Tree-Sitter System %
  %%%%%%%%%%%%%%%%%%%%%%%%%%

  \begin{frame}{O Sitema \treesitter}
    \begin{itemize}
      \item O \treesitter \cite{tree-sitter-2023-tree} é um sistema multilíngue
            de análise sintática para ferramentas de programação, desenvolvido
            como uma tentativa de solucionar problemas presentes nas
            ferramentas de análise sintática da época, tendo como objetivos
            \begin{itemize}
              \item Produzir árvores de sintaxe a partir da análise de códigos
                    escritos em várias linguagens
              \item Implementar a análise incremental, permitindo a atualização
                    da árvore de sintaxe em tempo real
              \item Expor através da árvore de sintaxe os nós representando
                    suas construções gramaticais no código (e.g., classes,
                    funções, declarações, etc.)
              \item Ser livre de dependências, assim beneficiando sua adoção e
                    aplicabilidade
            \end{itemize}
    \end{itemize}
  \end{frame}

  \begin{frame}{O Sitema \treesitter}
    \begin{itemize}
      \item Além disso, o \treesitter oferece uma pequena linguagem de
            consulta declarativa que é capaz de expressar padrões da árvore
            sintática por meio de \textit{S-expressions} e buscar
            correspondências
      \item Essa linguagem suporta operadores que permitem
            \begin{itemize}
              \item A captura de nós
              \item A quantificação de nós, análoga às expressões regulares
              \item O agrupamento de nós
              \item As alternâncias de nós
              \item O uso de \textit{wildcards}
              \item A ordenação de nós
            \end{itemize}
    \end{itemize}
  \end{frame}

  \begin{frame}{O Sitema \treesitter}
    \begin{itemize}
      \item Adicionalmente, a linguagem de consulta permite o uso de predicados
            --- funções arbitrárias geralmente utilizadas para filtrar nós ou
            realizar verificações mais complexas durante a busca de padrões
            ---, sejam eles \textit{builtins} ou estendidos por meio de uma API
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%%%
  % Materials %
  %%%%%%%%%%%%%

  \begin{frame}{Materiais}
    \begin{itemize}
      \item O \witchcooking foi desenvolvido com base
            \begin{itemize}
              \item No ecossistema Rust, composto
                    \begin{itemize}
                      \item Pela linguagem de programação Rust
                            \cite{rust-2023-rust}
                      \item Pelo gerenciador de pacotes \textit{Cargo}
                            \cite{rust-2023-cargo}
                      \item Pelo servidor de linguagem \textit{rust-analyzer}
                            \cite{rust-analyzer-2023-rust}
                    \end{itemize}
              \item No sistema/biblioteca \treesitter
                    \cite{tree-sitter-2023-tree}
              \item No ecossistema Neovim, composto
                    \begin{itemize}
                      \item Pelo editor de texto \textit{Neovim}
                            \cite{neovim-2023-hyperextensible}
                      \item Pelas configurações personalizadas
                            \cite{silva-2023-uma}
                      \item Pelo plugin \textit{nvim-treesitter}
                            \cite{nvim-treesitter-2023-nvim}
                      \item Pelo plugin \textit{playground}
                            \cite{nvim-treesitter-2023-playground}
                    \end{itemize}
            \end{itemize}
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%
  % Methods %
  %%%%%%%%%%%

  \begin{frame}{Métodos}
    \begin{itemize}
      \item Foi realizado uma pesquisa experimental com o objetivo de explorar
            a aplicação do \treesitter como base para o algoritmo de formatação
            de código-fonte
      \item Similarmente, foram integrados elementos de um estudo de caso com o
            propósito de analisar a eficácia do software desenvolvido
    \end{itemize}
  \end{frame}

  %%%%%%%%%
  % Usage %
  %%%%%%%%%

  \begin{frame}[fragile]{Usagem}
    \begin{itemize}
      \item \codesnippetinline{cook [-l LANG] -q QUERY [SRC]}
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % The Formatting Algorithm %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \begin{frame}{O Algoritmo de Formatação}
    \begin{center}
      \begin
        {tikzpicture}
        [node distance=1em,every node/.style={draw,inner sep=1em}]
        \tiny
        \node (init) {
          \begin
            {tikzpicture}
            [ every node/.style=
                {align=center,draw,inner sep=.5em,text width=14em}]
            \node [draw=none] (label) {Inicialização};
            \node (I) [below=of label] {Analisa a árvore de sintaxe};
            \node (II) [below=of I] {Gera o objeto de consulta};
            \node (III) [below=of II] {Instancia a estrutura editora};
            \node (IV) [below=of III] {Inicializa o objeto de configurações};
            \node (V) [below=of IV] {Deriva a estrutura de correspondências};
            \draw [->] (I) -- (II);
            \draw [->] (II) -- (III);
            \draw [->] (III) -- (IV);
            \draw [->] (IV) -- (V);
          \end{tikzpicture}
        };
        \node (fmt) [right=of init] {
          \begin
            {tikzpicture}
            [ every node/.style=
                {align=center,draw,inner sep=.5em,text width=14em}]
            \node [draw=none,text width=16em] (label) {Formatação};
            \path
              let \p1=(label.south west)
              in coordinate (I-coord) at ($ (\x1,\y1-2em) $);
            \node (I) at (I-coord) {Itera sobre os padrões};
            \node (II) [below=of I] {Define o escopo de atuação};
            \node
              (III)
              [below=of II]
              {Itera sobre as coleções\\de nós capturados};
            \node (IV) [below=of III] {Aplica as configurações};
            \node (V) [below=of IV] {Aplica os predicados gerais};
            \node (VI) [below=of V] {Redefine as\\configurações locais};
            \node
              (VII)
              [below=of VI]
              {Interrompe a iteração de\\coleções se o padrão\\é enraizado};
            \draw [->] (I) -- (II);
            \draw [->] (II) -- (III);
            \draw [->] (III) -- (IV);
            \draw [->] (IV) -- (V);
            \draw [->] (V) -- (VI);
            \draw [->] (VI) -- (VII);
            \draw [->] (VII.east) -- ++(1em,0) |- (III.east);
            \draw [->] (VII.east) -- ++(2em,0) |- (I.east);
          \end{tikzpicture}
        };
        \draw [->] (init) -- (fmt);
        \node (ret) [right=of fmt] {
          \begin
            {tikzpicture}
            [ every node/.style=
                {align=center,draw,inner sep=.5em,text width=16em}]
            \node [draw=none] (label) {Retorno};
            \node
              (label)
              [below=of label]
              {Retorna o código-fonte formatado};
          \end{tikzpicture}
        };
        \draw [->] (fmt) -- (ret);
      \end{tikzpicture}
    \end{center}
  \end{frame}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % The Formatting Guidelines %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \begin{frame}[fragile]{As Diretrizes de Formatação}
    \begin{itemize}
      \item As diretrizes de formatação do código-fonte são especificadas no
            arquivo escrito na linguagem de consulta do \treesitter, o qual é
            submetido ao \witchcooking via \codesnippetinline{-q QUERY}
      \item Para realizar um procedimento de formatação, é necessário
            \begin{itemize}
              \item Definir um padrão de correspondência que delimita o escopo
                    de operação
              \item Capturar nós que
                    \begin{itemize}
                      \item Sejam alvos do procedimento
                      \item Auxiliarão nas operações
                    \end{itemize}
              \item Opcionalmente, aplicar configurações via o predicado
                    \codesnippetinline{set!}
              \item Aplicar os predicados estendidos pelo \witchcooking
            \end{itemize}
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%%%%%%%%%%%%
  % The Configurations %
  %%%%%%%%%%%%%%%%%%%%%%

  \begin{frame}[fragile]{As Configurações}
    \begin{itemize}
      \item \codesnippetinline{indent-rule}
            \begin{itemize}
              \item Define a regra de indentação para um nó
              \item Seu valor pode ser
                    \begin{itemize}
                      \item Um inteiro não negativo --- sem sinal
                      \item Um inteiro positivo --- com sinal
                      \item Um inteiro negativo
                    \end{itemize}
            \end{itemize}
      \item \codesnippetinline{indent-style}
            \begin{itemize}
              \item Define a string usada para indentar
              \item Pode ser de escopo local ou global
              \item Não aplicável a nós
            \end{itemize}
    \end{itemize}
  \end{frame}

  %%%%%%%%%%%%%%%%%%
  % The Predicates %
  %%%%%%%%%%%%%%%%%%

  %%%%%%%%%%%
  %% space! %
  %%%%%%%%%%%

  \begin{frame}[fragile]{Os Predicados}{\textit{space!}}
    \begin{itemize}
      \item \codesnippetinline{(#space! [sep [lower [upper]]] a b)}
            \begin{itemize}
              \item Separa os nós \codesnippetinline{a} e \codesnippetinline{b}
                    com a string \codesnippetinline{sep}
              \item Por padrão, \codesnippetinline{sep} é um caractere de
                    espaço
              \item \codesnippetinline{lower} e \codesnippetinline{upper} podem
                    ser utilizados para definir um intervalo inclusivo para não
                    atuação
            \end{itemize} \end{itemize}
  \end{frame}

  \begin{frame}[fragile]{Os Predicados}{\textit{space!}}
    \begin{minipage}[t]{\halftextwidthplustwoemcounterpart}
      \begin{codesnippet}[rust]{Função Com Bloco Aglomerado em Rust}
        fn x_plus_y() -> u32 {
          let x = 5; let y = 11;

          x + y
        }
      \end{codesnippet}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{\halftextwidthplustwoempart}
      \begin
        {codesnippet}%
        [scheme]%
        {Consulta para Separar Elementos do Corpo de uma Função em Rust}
        (function_item
          body: (block (_) @item . (_) @next)
          (#space! "\n" 2 @item @next))
      \end{codesnippet}
    \end{minipage}

    \begin
      {codesnippet}%
      [rust]%
      {Função Com Elementos do Corpo Separados em Rust}
      fn x_plus_y() -> u32 {
        let x = 5;
      let y = 11;

        x + y
      }
    \end{codesnippet}
  \end{frame}

  %%%%%%%%%%%%
  %% indent! %
  %%%%%%%%%%%%

  \begin{frame}[fragile]{Os Predicados}{\textit{indent!}}
    \begin{itemize}
      \item \codesnippetinline{(#indent! node...)}
            \begin{itemize}
              \item Aplica a indentação previamente configurada para cada
                    \codesnippetinline{node}
              \item Cada nó deve ter sua regra de indentação especificada ---
                    via \codesnippetinline{indent-rule} ou
                    \codesnippetinline{indent-offset!}
              \item Um estilo de indentação deve ser configurado --- via
                    \codesnippetinline{indent-style}
            \end{itemize} \end{itemize}
  \end{frame}

  \begin{frame}[fragile]{Os Predicados}{\textit{indent!}}
    \begin{minipage}[t]{\halftextwidthplustwoemcounterpart}
      \begin{codesnippet}[rust]{Função Com Bloco Aglomerado em Rust}
        fn x_plus_y() -> u32 {
          let x = 5; let y = 11;

          x + y
        }
      \end{codesnippet}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{\halftextwidthplustwoempart}
      \begin
        {codesnippet}%
        [scheme]%
        { Consulta para Separar Elementos do Corpo de uma Função Com Indentação
          em Rust}
        (#set! indent-style "  ")

        (function_item
          body: (block (_) @item . (_) @next)
          (#space! "\n" 2 @item @next)
          (#set! @next indent-rule "+1")
          (#indent! @next))
      \end{codesnippet}
    \end{minipage}

    \begin
      {codesnippet}%
      [rust]%
      {Função Com Indentação Apropriada em Rust}
      fn x_plus_y() -> u32 {
        let x = 5;
        let y = 11;

        x + y
      }
    \end{codesnippet}
  \end{frame}

  %%%%%%%%%%%%%%%%%%%
  %% indent-offset! %
  %%%%%%%%%%%%%%%%%%%

  \begin{frame}[fragile]{Os Predicados}{\textit{indent-offset!}}
    \begin{itemize}
      \item \codesnippetinline{(#indent-offset! target ref)}
            \begin{itemize}
              \item Configura a regra de indentação --- i.e.,
                    \codesnippetinline{indent-rule} --- de
                    \codesnippetinline{target} como o deslocamento de
                    \codesnippetinline{ref}
            \end{itemize} \end{itemize}
  \end{frame}

  \begin{frame}[fragile]{Os Predicados}{\textit{indent-offset!}}
    \begin{minipage}[t]{\halftextwidthplusfiveemcounterpart}
      \begin{codesnippet}[rust]{Função Compactada}
        fn foo() {bar()}
      \end{codesnippet}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{\halftextwidthplusfiveempart}
      \begin
        {codesnippet}%
        [scheme]%
        { Consulta para Formatar uma Função em Rust de Acordo Com o Estilo
          \textit{1TBS}}
        (#set! indent-style "    ")

        ( (function_item
            body: (block (_) @item "}" @close)) @fn
          (#set! @item indent-rule "+1")
          (#indent-offset! @close @fn)
          (#indent! @item @close))
      \end{codesnippet}
    \end{minipage}

    \begin
      {codesnippet}%
      [rust]%
      {Função em Rust Indentada de Acordo Com o Estilo \textit{1TBS}}
      fn foo() {
          bar()
      }
    \end{codesnippet}
  \end{frame}

  %%%%%%%%%%%%%%%%
  % Bibliography %
  %%%%%%%%%%%%%%%%

  \begin{frame}[allowframebreaks]{Referências}\printbibliography\end{frame}
\end{document}