@gd{builtin,
  word={builtin},
  definition=
    { No desenvolvimento de software, \textit{``builtin''} é um termo utilizado
      para descrever funções ou comandos que são incorporados no próprio
      sistema ou ambiente de programação, em contraste com funções ou comandos
      definidos pelo usuário ou programador. Por exemplo, em Python, a função
      \textit{print} é um exemplo de função \textit{builtin}. Essas funções ou
      comandos \textit{builtin} estão prontamente disponíveis, o que significa
      que não é necessário definir ou importá-los explicitamente por parte do
      usuário ou programador}}

@gd{code-folding,
  word={code folding},
  definition=
    { No desenvolvimento de software, \textit{code folding} é uma
      \textit{feature} que permite a ocultação seletiva de partes de um
      documento ou código-fonte, permitindo ao usuário ou programdor visualizar
      apenas as seções de interesse. Esse recurso é especialmente útil ao lidar
      com grandes volumes de informações, possibilitando uma melhor organização
      e foco em seções específicas. O \textit{code folding} é comumente
      utilizado em ambientes de programação que possuem estruturas
      hierárquicas, como árvores ou blocos aninhados, facilitando a navegação e
      a compreensão do código}}

@gd{feature,
  word={feature},
  definition=
    { Na programação de computadores, uma \textit{feature} é uma funcionalidade
      específica ou capacidade de um software que agrega valor ao sistema. Uma
      \textit{feature} pode ser um componente, uma função, um conjunto de
      comandos ou qualquer outra característica que ofereça uma determinada
      funcionalidade aos usuários do software. Ela pode abranger desde recursos
      básicos até funcionalidades mais avançadas e personalizadas, e é
      projetada para atender às necessidades e demandas dos usuários, melhorar
      a usabilidade do software e fornecer uma experiência mais completa}}

@gd{fifo,
  word={FIFO},
  definition=
    { Na computação e na teoria de sistemas, ``FIFO'' é um acrônimo para
      \textit{``\textbf{F}irst \textbf{I}n, \textbf{F}irst \textbf{O}ut''} -- o
      primeiro a entrar é o primeiro a sair --, um método para organizar a
      manipulação de uma estrutura de dados -- geralmente, especificamente um
      buffer de dados -- onde a entrada mais antiga (primeira), ou ``cabeça''
      da fila, é processada primeiro}}

@gd{garbage-collection,
  word={garbage collection},
  short={GC},
  definition=
    { Em ciência da computação, \textit{garbage collection} (GC), ou coleta de
      lixo, é uma forma de gerenciamento automático de memória. O coletor de
      lixo tenta recuperar a memória que foi alocada pelo programa, mas que não
      está mais sendo referenciada; essa memória é chamada de lixo. A coleta de
      lixo foi inventada pelo cientista da computação americano John McCarthy
      por volta de 1959 para simplificar o gerenciamento manual de memória em
      Lisp}}

@gd{homoiconic,
  word={homoicônico},
  definition=
    { Na programação de computadores, a homoiconicidade -- das palavras gregas
      \textit{``homo-''}, que significa ``o mesmo'', e \textit{``icon'}, que
      significa ``representação'' -- é uma propriedade de algumas linguagens de
      programação. Uma linguagem é homoicônica se um programa escrito nela pode
      ser manipulado como dados utilizando a própria linguagem, permitindo
      inferir a representação interna do programa apenas lendo o próprio
      programa. Essa propriedade é frequentemente resumida dizendo que a
      linguagem trata o \textbf{código como dados}}}

@gd{loop,
  word={loop},
  definition=
    { Na programação de computadores, \textit{loop} -- também conhecido em
      português como ``estrutura de repetição'' ou ``laço de repetição'' -- é
      uma sequência de declarações que é especificada uma vez, mas que pode ser
      executada várias vezes em sucessão. O código ``dentro'' do \textit{loop}
      -- o corpo do \textit{loop} -- é executado:
      \begin{inparaenum}
        \item um número especificado de vezes, ou
        \item uma vez para cada item de uma coleção, ou
        \item até que alguma condição seja satisfeita, ou
        \item indefinidamente\end{inparaenum}}}

@gd{opinionated,
  word={opinionated},
  definition=
    { No desenvolvimento de software, \textit{``opinionated''} é um termo
      utilizado para se referir a um conjunto de práticas preestabelecidas
      sobre como abordar uma determinada tarefa, podendo não permitir
      customizações ou desvio das abordagens. O termo foi popularizado a partir
      da obra \textit{Getting Real: The smarter, faster, easier way to build a
      successful web application}, escrita por \textcite{fried-2009-getting}}}

@gd{parser,
  word={parser},
  definition=
    { Na programação de computadores, um \textit{parser} (ou analisador) é um
      componente de software que recebe dados de entrada (frequentemente texto)
      e constrói uma estrutura de dados -- frequentemente algum tipo de árvore
      de análise, árvore de sintaxe abstrata ou outra estrutura hierárquica --
      fornecendo uma representação estrutural da entrada enquanto verifica a
      sintaxe correta. A análise pode ser precedida ou seguida por outras
      etapas, ou essas etapas podem ser combinadas em uma única etapa. O
      \textit{parser} é frequentemente precedido por um analisador léxico
      (\textit{lexer}) separado, que cria \textit{tokens} a partir da sequência
      de caracteres de entrada; alternativamente, esses elementos podem ser
      combinados na análise sem scanner. \textit{Parsers} podem ser programados
      manualmente ou podem ser gerados automaticamente ou semi-automaticamente
      por um gerador de \textit{parser}}}

@gd{pipeline,
  word={pipeline},
  definition=
    { Em sistemas operacionais de computador semelhantes ao Unix,
      \textit{pipeline} é um mecanismo para comunicação entre processos usando
      passagem de mensagens. Um \textit{pipeline} é um conjunto de processos
      encadeados por seus fluxos padrão, de modo que o texto de saída de cada
      processo (\textit{stdout}) é passado diretamente como entrada
      (\textit{stdin}) para o próximo. O segundo processo é iniciado enquanto o
      primeiro processo ainda está executando, e eles são executados
      simultaneamente}}

@gd{prettyprinting,
  word={prettyprinting},
  short={PP},
  definition=
    { Na programação de computadores, \textit{prettyprinting} é a aplicação de
      diversas convenções estilísticas de formatação a arquivos de texto, como
      código-fonte, marcação e conteúdos similares. Essas convenções de
      formatação podem incluir o uso de estilos de indentação, cores e tipos de
      fonte diferentes para destacar elementos sintáticos do código-fonte, ou
      ajustes de tamanho, para tornar o conteúdo mais fácil de ser lido e
      compreendido por pessoas. \textit{Prettyprinters} para código-fonte são
      às vezes chamados de ``formatadores de código'' ou
      \textit{``beautifiers''}}}

@gd{sexp,
  word={s-expression},
  short={Sexp},
  definition=
    { Na programação de computadores, uma \textit{S-expression} -- ou expressão
      simbólica, abreviada como \textit{``sexpr''} ou \textit{``sexp''} -- é
      uma expressão em uma notação de mesmo nome para dados em lista aninhada
      (estruturados em árvore). As \textit{S-expressions} foram inventadas e
      popularizadas pela linguagem de programação LISP, que as utiliza tanto
      para código-fonte quanto para dados}}

@gd{token,
  word={token},
  definition=
    { Na análise léxica, um \textit{token} refere-se a uma unidade, que é a
      menor unidade reconhecível em um programa de computador escrito em uma
      linguagem de programação. Um \textit{token} é uma sequência de caracteres
      que representa uma entidade específica, como uma palavra-chave, um
      identificador, um operador, um número ou um símbolo especial}}

@gd{wildcard,
  word={wildcard},
  definition=
    { No software, um \textit{wildcard} é um tipo de espaço reservado
      geralmente representado por um único caractere -- como um asterisco (`*')
      -- ou símbolo especial, que pode representar:
      \begin{inparaenum}
        \item qualquer outro caractere; um
        \item conjunto de caracteres;
        \item objetos, elementos, símbolos, etc.; ou até
        \item nada, ou seja, nenhum caractere ou objeto, elemento,
              símbolo, etc.
      \end{inparaenum}
      Os usos mais comuns de \textit{wildcards} são em:
      \begin{inparaenum}
        \item expressões regulares (\textit{regex}), onde um caractere especial
              é usado para representar um conjunto de caracteres desconhecidos
              ou variáveis em uma string; e na
        \item interface de linha de comando, onde as \textit{shells}
              normalmente disponiblizam o caractere asterisco (`*') para
              corresponder a nomes de arquivos\end{inparaenum}}}

@gd{zero-cost-abs,
  word={zero-cost abstractions},
  definition=
    { Na programação de computadores, \textit{Zero-cost abstractions} (ou
      abstrações de custo zero) é um conceito que se refere à capacidade de
      usar abstrações de alto nível e recursos da linguagem sem incorrer em
      penalidades de desempenho em tempo de execução. Isso significa que o
      programador pode escrever código de forma mais abstrata, expressiva e
      amigável para o desenvolvedor, enquanto o sistema subjacente gera código
      de máquina altamente eficiente}}