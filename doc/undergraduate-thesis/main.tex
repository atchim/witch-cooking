\documentclass
  [11pt, a4paper, english, openright, sumario = tradicional, twoside, brazil]
  {abntex2}

%%%%%%%%%%%%
% Preamble %
%%%%%%%%%%%%

%%%%%%%%%%%%%
%% Packages %
%%%%%%%%%%%%%

\usepackage{palatino}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{indentfirst}
\usepackage{nomencl}
\usepackage{color}
\usepackage{graphicx}
\usepackage{microtype}
\usepackage{csquotes}
\usepackage[backend = biber, indent, style = abnt]{biblatex}
\usepackage{paralist}
\let\glossitem\undefined\usepackage[portuguese]{gloss}

%%%%%%%%%%%%%%%%%%
%% Configuration %
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% ABNT's NBR 14724 Metrics Compliance %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\setlength{\parindent}{1.3cm}
\setlength{\parskip}{0.2cm}

%%%%%%%%%%%%%
%%% abntex2 %
%%%%%%%%%%%%%

\renewcommand{\ABNTEXchapterfont}{\fontseries{b}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Cover & Title Page Info %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\titulo
  {\textit{Witch Cooking}: Formatação de Código via Linguagem de Consulta do
   \textit{Tree-Sitter}}
\autor{Átila Gama Silva}
\local{Irecê}
\data{\the\year}
\orientador{Rafael Xavier}
\instituicao
  {Instituto Federal de Educação, Ciência e Tecnologia da Bahia – Campus Irecê}
\tipotrabalho{Trabalho de Conclusão de Curso}
\preambulo
  {Trabalho de Conclusão de Curso apresentado ao Curso Técnico em Análise e
   Desenvolvimento de Sistemas do Instituto Federal de Educação, Ciência e
   Tecnologia da Bahia – Campus Irecê, como requisito parcial para obtenção do
   diploma de Técnico em Análise e Desenvolvimento de Sistemas, mediante a
   orientação do professor \imprimirorientador.}

%%%%%%%%%%%%%%%%%%%
%%%% IFBA's Cover %
%%%%%%%%%%%%%%%%%%%

\renewcommand
  {\imprimircapa}
  {\begin{capa}
     \ABNTEXchapterfont
     \ABNTEXsectionfontsize
     \center
     \includegraphics[width=\textwidth]{ifba-irece-logo.png}
     \par\vfill\imprimirautor
     \par\vfill{\ABNTEXchapterfontsize\imprimirtitulo}
     \vfill\vfill
     \par\imprimirlocal\break\imprimirdata
   \end{capa}}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%% IFBA's Title Page %
%%%%%%%%%%%%%%%%%%%%%%%%

\makeatletter
\renewcommand
  {\folhaderostocontent}
  {\begin{center}
     \ABNTEXchapterfont
     \ABNTEXsectionfontsize
     \imprimirautor
     \par\vfill\vfill{\ABNTEXchapterfontsize\imprimirtitulo}
     \vfill
     {\normalsize
      \mdseries
      \hspace{.45\textwidth}
      \begin{minipage}{.5\textwidth}
        \SingleSpacing
        \imprimirpreambulo
      \end{minipage}}
     \vfill\vfill
     \imprimirlocal\break\imprimirdata
   \end{center}}
\makeatother

%%%%%%%%%%%%%%
%%%% Summary %
%%%%%%%%%%%%%%

\setlength{\cftlastnumwidth}{\cftchapternumwidth}
\cftsetindents{part}{0em}{\cftlastnumwidth}
\cftsetindents{chapter}{0em}{\cftlastnumwidth}
\cftsetindents{section}{0em}{\cftlastnumwidth}
\cftsetindents{subsection}{0em}{\cftlastnumwidth}
\cftsetindents{subsubsection}{0em}{\cftlastnumwidth}
\cftsetindents{paragraph}{0em}{\cftlastnumwidth}
\cftsetindents{subparagraph}{0em}{\cftlastnumwidth}

\renewcommand
  {\tocprintchapter}
  {\addtocontents{toc}{\cftsetindents{chapter}{0em}{\cftlastnumwidth}}}

\renewcommand
  {\tocinnonumchapter}
  {\addtocontents{toc}{\cftsetindents{chapter}{\cftlastnumwidth}{2em}}
   \cftinserthook{toc}{A}}

\renewcommand
  {\tocprintchapternonum}
  {\addtocontents{toc}{\cftsetindents{chapter}{\cftlastnumwidth}{2em}}}

\renewcommand
  {\tocpartapendices}
  {\addtocontents{toc}{\cftsetindents{part}{\cftlastnumwidth}{2em}}
   \cftinserthook{toc}{A}}

\renewcommand
  {\tocpartanexos}
  {\addtocontents{toc}{\cftsetindents{part}{\cftlastnumwidth}{2em}}
   \cftinserthook{toc}{A}}

\setlength{\cftbeforechapterskip}{1em}

%%%%%%%%%%%%%%%%%%
%%% Bibliography %
%%%%%%%%%%%%%%%%%%

\addbibresource{references.bib}

%%%%%%%%%%%%%%
%%% Glossary %
%%%%%%%%%%%%%%

\setglosslabel{\bfseries#2\ifglossshort{ (#3)}{}}
\renewenvironment{thegloss}
  {\chapter*{\glossname}
   \markboth{\glossname}{\glossname}
   \addcontentsline{toc}{chapter}{\glossname}}
  {\stopglosslist}
\makegloss

%%%%%%%%%%%%%%
%%% Paralist %
%%%%%%%%%%%%%%

\setdefaultenum{(I)}{(A)}{}{}

%%%%%%%%%
%%% PDF %
%%%%%%%%%

\definecolor{blue}{RGB}{41,5,195}
\makeatletter
\hypersetup
  {pdftitle       = {\@title},
   pdfauthor      = {\@author},
   pdfsubject     = {\textit{Witch Cooking}: Formatação de Código via Linguagem
                     de Consulta do \textit{Tree-Sitter}},
   pdfcreator     = {\LaTeX with \abnTeX},
   pdfkeywords    = {formatação de código}
                    {\textit{Tree-Sitter}}
                    {\textit{prettyprint}}
                    {customização}
                    {\textit{query}},
   colorlinks     = true,
   linkcolor      = blue,
   citecolor      = blue,
   filecolor      = magenta,
   urlcolor       = blue,
   bookmarksdepth = 4}
\makeatother

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\begin{document}
  \selectlanguage{brazil}
  \frenchspacing

  %%%%%%%%%%%%%%
  % Pretextual %
  %%%%%%%%%%%%%%

  \imprimircapa
  \imprimirfolhaderosto

  %%%%%%%%%%%%
  % Abstract %
  %%%%%%%%%%%%

  \setlength{\absparsep}{18pt}

  \begin{resumo}
    A formatação de código é fundamental no desenvolvimento de software,
    permitindo estabelecer aspectos desejados como a padronização e
    legibilidade do código, que impactam positivamente o ciclo de vida do
    software. Em ambientes de desenvolvimento modernos, é comum o uso de
    ferramentas para automatizar a formatação de código. No entanto, essas
    ferramentas apresentam limitações no número de linguagens suportadas, nas
    opções de configuração e não permitem a definição de regras de formatação
    personalizadas. Visando superar ou reduzir as limitações frequentemente
    encontradas nas ferramentas convencionais de formatação, neste trabalho é
    apresentado o \textit{Witch Cooking}, um software protótipo que tem como
    objetivos:
    \begin{inparaenum}
      \item abranger uma gama de linguagens de programação; além de
      \item permitir que o usuário defina suas próprias regras de formatação.
    \end{inparaenum}

    \noindent
    \textbf{Palavras-chave}:
    formatação de código;
    \textit{Tree-Sitter};
    \textit{prettyprint};
    customização;
    \textit{query}.
  \end{resumo}

  %%%%%%%%%%%%%%%%%%%%%
  % Table of Contents %
  %%%%%%%%%%%%%%%%%%%%%

  \pdfbookmark[0]{\contentsname}{toc}
  \tableofcontents*
  \cleardoublepage

  %%%%%%%%%%%%%%%%%%%%
  % Textual Elements %
  %%%%%%%%%%%%%%%%%%%%

  \textual

  %%%%%%%%%%%%%%%%%
  %% Introduction %
  %%%%%%%%%%%%%%%%%

  \chapter{Introdução}

  A flexibilidade presente na sintaxe de linguagens de programação permite que
  diferentes arranjos dum mesmo código compartilhem um valor sintático
  equivalente. Essa característica possibilita a formatação do código de acordo
  com aspectos desejados, como a legibilidade, que é fundamental no ciclo de
  vida do software \cites[546]{buse-2009-learning}[1]{oliveira-2020-evaluating}.
  Consequentemente, a formatação é frequentemente utilizada para estabelecer um
  nível satisfatório de legibilidade em bases de código.

  A formatação de código pode ser realizada manualmente pelo programador,
  embora esse processo possa ser demorado, especialmente em grandes bases de
  código, exigindo do programador um tempo que poderia ser empregado em outra
  tarefa. Além disso, a formatação manual também pode ser falha e inconsistente
  devido à suscetibilidade humana ao erro, podendo ser agravada quando há
  múltiplos programadores em uma base de código.

  Para evitar os problemas inerentes da formatação manual, é comum a utilização
  de softwares que automatizam a formatação de forma determinística, tornando o
  código padronizado e consistente. No entanto, é comum que essas ferramentas
  de formatação sejam limitadas a uma linguagem ou a uma família de linguagens
  de programação. Além disso, algumas delas são \textit{\gloss{opinionated}},
  assim restringindo as possiblidades de customização do usuário. Finalmente, é
  também comum que essas ferramentas de formatação não permitam que o usuário
  defina regras de formatação personalizadas.

  Em ambientes de desenvolvimento modernos, além da utilização de ferramentas
  que automatizam a formatação de código, é também comum a utilização do
  \textit{Tree-Sitter} \cite{tree-sitter-2018-tree}: um sistema de análise
  sintática de código aberto que foi disponibilizado ao público geral no GitHub
  primeiramente em 2019, tendo sido inicialmente desenvolvido por Max
  Brunsfeld. Desde seu lançamento, o \textit{Tree-Sitter} tem ganhado
  popularidade na comunidade de desenvolvedores devido dentre outros motivos à:
  \begin{inparaenum}
    \item sua capacidade de suportar várias linguagens de programação; além de
    \item sua linguagem de consulta, a qual permite a realização de buscas
          complexas na árvore analisada de um código fonte.
  \end{inparaenum}

  Visando superar ou reduzir as limitações previamente mencionadas, quais são
  frequentemente presentes nas ferramentas convencionais de formatação, este
  trabalho tem como objetivo geral desenvolver um software protótipo para a
  formatação de código. Nomeada antecipadamente de \textit{Witch Cooking}
  \cite{silva-2023-witch} pelo autor, a ferramenta a ser desenvolvida tem como
  objetivos:
  \begin{inparaenum}
    \item abranger uma gama de linguagens de programação; além de
    \item permitir que o usuário defina suas próprias regras de formatação.
  \end{inparaenum}

  Para alcançar o objetivo geral proposto, este trabalho tem como objetivos
  específicos:
  \begin{inparaenum}
    \item apresentar e contextualizar ferramentas de formatação de código
          conceituadas, além de abordar seus métodos de formatação;
    \item conceituar, contextualizar e abordar as tecnologias do sistema
          \textit{Tree-Sitter}; e, por fim,
    \item utilizar o \textit{Tree-Sitter} para desenvolver e atender às
          aspirações do \textit{Witch Cooking}.
  \end{inparaenum}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %% The Source Code Formatting %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \chapter{A Formatação de Código-Fonte}

  Desde os primórdios da computação, métodos foram desenvolvidos para garantir
  que a saída impressa fosse formatada de maneira esteticamente agradável
  \apud{harris-1956-keyboard}[1]{yelland-2015-rfmt}. Esses métodos ganharam
  popularidade sob o termo \textit{\gloss{prettyprinting}}, que se refere à
  formatação visual de diversos tipos de conteúdo. No desenvolvimento de
  software, o \textit{prettyprinting} é conhecido como formatação de código:
  uma prática histórica e comum que envolve a adoção de convenções estilísticas
  para estruturar o código-fonte. Existem diversas terminologias utilizadas
  para se referir às ferramentas que realizam a formatação do código-fonte,
  incluindo:
  \begin{inparaenum}
    \item formatadores de código, ou \textit{code formatters} em inglês;
    \item \textit{prettyprinters}; ou ainda
    \item \textit{beautifiers}.
  \end{inparaenum}

  Durante as décadas de 60 e 70, a linguagem de programação LISP%
  \footnote
    {O termo LISP (acrônimo para \textit{\textbf{LIS}t \textbf{P}rocessing})
     inicialmente se referia à linguagem de programação desenvolvida por
     \textcite{mccarthy-1960-recursive}, porém, com a disseminação de dialetos
     da linguagem, o termo também passou a ser utilizado para se referir à
     família de linguagens derivadas da original.}
  proporcionou condições favoráveis para o avanço da formatação de código
  \cite[2]{yelland-2015-new}.
  \begin{inparaenum}
    \item LISP apresentava uma sintaxe distinta e expressiva, baseada em listas
          e estruturas aninhadas delimitadas por parênteses%
          \footnote
            {Na notação original de McCarthy, eram utilizadas
             \textit{M-expressions} entre colchetes para representar
             expressões. Essas \textit{M-expressions} seriam posteriormente
             traduzidas em \textit{S-expressions}. Por exemplo, a
             \textit{M-expression} ``\texttt{car[cons[A; B]]}'' seria
             equivalente à \textit{S-expression} ``\texttt{(car (cons A B))}''.
             No entanto, assim que a linguagem LISP foi implementada, os
             programadores prontamente adotaram o uso das
             \textit{S-expressions} em vez das \textit{M-expressions}, tornando
             as \textit{S-expressions} a forma predominante de representar a
             estrutura do código na linguagem.},
          o que tornava o código-fonte praticamente ilegível e incompreensível
          caso não fosse devidamente organizado. Além disso,
    \item LISP era \gloss{homoiconic}, ou seja, permitia a manipulação do
          código via dados da própria linguagem.
  \end{inparaenum}
  Essas duas características intrínsecas do LISP fundamentaram o surgimento de:
  \begin{inparaenum}
    \item \textit{prettyprinters} para a linguagem, visando aperfeiçoar a
          legibilidade do código-fonte escrito ou emitido; além de
    \item novas técnicas e abordagens para a formatação de código em geral.
  \end{inparaenum}
  Esses avanços contribuíram significativamente para o conhecimento e o
  aprimoramento de práticas de formatação de código em trabalhos subsequentes.

  Em 1967, Bill Gosper desenvolveu o \textit{GRINDEF} (acrônimo para
  \textit
    {\textbf{GRIND}%
     \footnote
       {O termo \textit{grind} era utilizado em alguns círculos de LISP como
        sinônimo para \textit{prettyprinters}.}
     \textbf{F}unction}%
  ), considerado o primeiro \textit{prettyprinter} a mensurar o tamanho das
  linhas e ter ciência de sua localização no arquivo
  \cites{gosper-2023-twubblesome}{griesemer-2022-cultural}. Essa ferramenta
  implementava o algoritmo \textit{recursive re-predictor}, que, como descrito
  por \textcite{goldstein-1973-pretty}, percorria as árvores de nós
  representando as listas e imprimia os nós considerando seus tamanhos e a
  quantidade máxima de caracteres que ainda poderiam ser inseridos em uma
  linha.

  Posteriormente, \textcite{hearn-1979-one} propuseram um algoritmo mais
  elaborado para \textit{prettyprinting} que utilizava um par de corrotinas%
  \footnote
    {Na obra, os autores enfatizam que a implementação com o uso de corrotinas
     é tão simples que poderia ser simulada -- sem grandes dificuldades -- em
     linguagens que não possuíam suporte nativo para corrotinas
     \cite[53]{hearn-1979-one}.}:
  uma
  \begin{inparaenum}
    \item responsável por produzir uma sequência de caracteres que
          representavam o programa sendo impresso; e outra
    \item responsável por decidir como esses caracteres seriam exibidos.
  \end{inparaenum}
  Essas corrotinas se comunicavam por meio de um buffer \textit{\gloss{fifo}},
  permitindo que as decisões de formatação fossem adiadas até que houvesse
  informações suficientes disponíveis para tomá-las com confiabilidade.

  No ano seguinte, \textcite{oppen-1980-prettyprinting} apresentou em sua
  influente obra, intitulada \textit{Prettyprinting}, um algoritmo inovador
  de formatação de código-fonte. Embora apresentasse semelhanças ao algoritmo
  proposto por \textcite{hearn-1979-one}, destacava-se por sua capacidade de
  formatar código derivado de qualquer linguagem de programação. Para realizar
  essa tarefa, o algoritmo necessitava que o código-fonte fosse anotado com
  espaços em branco%
  \footnote
    {Quebras de linha, avanços de formulário e alimentações de linha também
     eram tratados como espaços em branco pelo algoritmo.}
  e delimitadores especiais para marcar o início e fim de blocos logicamente
  contíguos. Assim, o código a ser fornecido ao algoritmo precisaria ser
  processado por uma ferramenta intermediária capaz de compreender a sintaxe da
  linguagem e fornecer um código anotado de forma adequada, permitindo que o
  algoritmo realizasse a formatação apropriada.

  Desde então, uma ampla variedade de \textit{prettyprinters} e trabalhos
  relacionados ao tema têm sido lançados e publicados. Mais recentemente, por
  exemplo, em \textit{A New Approach to Optimal Code Formatting},
  \textcite{yelland-2015-new} descreveu os fundamentos do algoritmo (de
  formatação de código) utilizado no \textit{rfmt} \cite{yelland-2015-rfmt},
  além das abstrações utilizadas para facilitar a implementação do algoritmo em
  uma variedade de linguagens e políticas de layout.

  %%%%%%%%%%%%%%%%%%%%%%%%%%%
  %% The Tree-Sitter System %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%

  \chapter{O Sistema \textit{Tree-Sitter}}

  O \textit{Tree-Sitter} é um sistema multilingual de análise sintática para
  ferramentas de programação inicialmente desenvolvido como um projeto
  secundário por Max Brunsfeld. Como relatado pelo próprio autor
  \cite{github-2017-tree}, o \textit{Tree-Sitter} surgiu como uma tentativa de
  solucionar problemas presentes nas ferramentas de análise sintática da época.
  Mais especificamente, o sistema tinha como objetivos:
  \begin{inparaenum}
    \item ser utilizado no ambiente de desenvolvimento para produzir árvores de
          sintaxe a partir da análise de códigos escritos em várias linguagens;
    \item implementar a análise incremental, permitindo a atualização da árvore
          de sintaxe em tempo real;
    \item expor através da árvore de sintaxe os nós representando suas
          construções gramaticais no código (\textit{e.g.}, classes, funções,
          declarações, etc.), diferentemente das ferramentas contemporâneas,
          que utilizavam uma abordagem simplística baseada em expressões
          regulares; e, por fim,
    \item ser livre de dependências, assim beneficiando sua adoção e
          aplicabilidade.
  \end{inparaenum}

  Além das funcionalidades previamente mencionadas presentes no
  \textit{Tree-Sitter}, o sistema também conta uma ferramenta de linha de
  comando que pode ser utilizada para gerar \textit{\gloss{parser}s} para uma
  linguagem a partir de sua gramática. A gramática é definida via a linguagem
  de programação JavaScript, a qual:
  \begin{inparaenum}
    \item foi eleita 15 vezes seguidas pela
          \textit{Stack Overflow Developer Survey}
          \cite{stack-overflow-2022-stack} como a linguagem de programação mais
          comumente usada; além de
    \item ser amplamente considerada pela comunidade de programadores
          como uma das linguagens mais fáceis de aprender e programar
          \cites {berkeley-2023-11}{goel-2023-how}{w3schools-2023-javascript}.
  \end{inparaenum}
  A ferramenta de geração de \textit{parsers} também disponibiliza funções
  preestabelecidas para permitir a criação de gramáticas com diferentes níveis
  de complexidade. Não é surpreendente que, devido a essas características e
  facilidades presentes na criação de \textit{parsers}, exista uma variedade de
  linguagens de programação e formatos de arquivos -- variando de linguagens
  com sintaxes complexas, como C++ e Perl, a formatos de arquivos mais
  específicos, como \textit{.vhs} e \textit{.rasi} --, os quais têm parsers
  gerados pelo \textit{Tree-Sitter} e são suportados pelo sistema.

  Na análise de código, é comum realizar tarefas que envolvem a busca de
  padrões em árvores sintáticas. Para isso, o \textit{Tree-Sitter} oferece uma
  pequena linguagem de consulta declarativa que é capaz de expressar esses
  padrões por meio de \textit{\gloss[Word]{sexp}} e buscar correspondências. A
  linguagem de consulta suporta operadores que permitem:
  \begin{inparaenum}
    \item a captura de nós;
    \item a quantificação de nós, análoga às expressões regulares;
    \item o agrupamento de nós;
    \item as alternâncias de nós;
    \item o uso de \textit{\gloss{wildcard}s}; e
    \item a ordenação de nós.
  \end{inparaenum}
  Adicionalmente, é possível definir propriedades nos nós da árvore sintática
  usando a linguagem de consulta do \textit{Tree-Sitter}. Também é permitido o
  uso de predicados -- funções arbitrárias para filtrar nós ou realizar
  verificações mais complexas durante a busca de padrões -- sejam eles
  \textit{\gloss{builtin}} ou estendidos por meio de uma API.

  Um exemplo da relevância e utilidade da linguagem de consulta é o plugin
  \textit{nvim-treesitter} \cite{nvim-treesitter-2023-nvim}, que é
  frequentemente utilizado no editor \textit{Neovim}
  \cite{neovim-2023-hyperextensible}. Esse plugin utiliza a linguagem de
  consulta para definir diferentes recursos, tais como:
  \begin{inparaenum}
    \item \textit{\gloss{code-folding}}, que permite ocultar blocos de código;
    \item highlights, que realçam a sintaxe do código;
    \item indentações, que definem a estrutura do código;
    \item injeções, que permitem adicionar novas sintaxes a arquivos
          existentes; além de
    \item captura de nós correspondentes a construções gramaticais
          (\textit{e.g.}, funções, classes, métodos, etc.), os quais são
          frequentemente utilizados em rotinas de programação tais como a
          remoção e navegação do código.
  \end{inparaenum}

  Em suma, o sistema \textit{Tree-Sitter} se mostrou uma solução inovadora e
  eficiente para a análise sintática de códigos em diversas linguagens de
  programação, com uma abordagem diferenciada e sofisticada que possibilita a
  atualização em tempo real das árvores sintáticas e a identificação precisa
  das construções gramaticais presentes no código. Além disso, a ferramenta de
  linha de comando disponível no sistema facilita a geração de parsers a partir
  de gramáticas definidas em JavaScript, o que torna o processo mais acessível
  e personalizável para os programadores. Finalmente, a linguagem de consulta
  declarativa oferecida pelo \textit{Tree-Sitter} se mostrou uma importante
  \textit{\gloss{feature}}, sendo utilizada em diversos plugins de editores de
  código para realizar tarefas variadas e sofisticadas, contribuindo
  significativamente no ambiente de desenvolvimento.

  %%%%%%%%%%%%%%%%%%%%%%
  %% The Witch Cooking %
  %%%%%%%%%%%%%%%%%%%%%%

  \chapter{O \textit{Witch Cooking}}

  Desenvolver um \textit{prettyprinter} não é uma tarefa simples
  \cite[55]{hughes-1995-design}. Durante o processo de formatação, é necessário
  \begin{inparaenum}
    \item ter conhecimento das estruturas gramaticais da sintaxe específica em
          questão. Além disso, o objetivo do \textit{prettyprinter} é
    \item\label{pl2} formatar o código de maneira otimizada e agradável para o
          leitor \cite[55]{hughes-1995-design}, levando em consideração as
          melhores práticas de formatação. Em alguns casos, também é importante
    \item permitir que o usuário possa optar por estilos de formatação
          que atenda às suas preferências individuais. Adicionalmente, as
          sintaxes das linguagens de programação costumam ser flexíveis em
          relação à estruturação do código-fonte. Assim, para atender o item
          \ref{pl2}, geralmente é necessário
    \item utilizar algoritmos que calculem o layout mais adequado de acordo
          com o contexto
          \cites
            {llvm-2023-clangformat}
            {goldstein-1973-pretty}
            {hughes-1995-design}
            {yelland-2015-new}.
  \end{inparaenum}
  Fatalmente, essas características essenciais de um \textit{prettyprinter}
  normalmente o restringem a uma linguagem específica ou, em alguns casos, a
  uma família de linguagens que compartilham semelhanças sintáticas ou
  estruturais.

  %%%%%%%%%%%%%%%
  %% Conclusion %
  %%%%%%%%%%%%%%%

  \chapter{Conclusão}

  %%%%%%%%%%%%%%%%%%%%%%%%%
  % Post Textual Elements %
  %%%%%%%%%%%%%%%%%%%%%%%%%

  \postextual
  \printbibliography
  \printgloss{glossary}
\end{document}