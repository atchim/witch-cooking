%%%%%%%%%%%%
% Preamble %
%%%%%%%%%%%%

\documentclass
  [11pt,a4paper,english,brazil,openright,sumario=tradicional,twoside]
  {abntex2}

%%%%%%%%%%%%%
%% Packages %
%%%%%%%%%%%%%

%%%%%%%%%%%%%%
%%% Encoding %
%%%%%%%%%%%%%%

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

%%%%%%%%%%%%%%%%%%%%%
%%% ABNT Compliance %
%%%%%%%%%%%%%%%%%%%%%

\usepackage{indentfirst}
\usepackage{microtype}

%%%%%%%%%%%%%%
%%% Glossary %
%%%%%%%%%%%%%%

\let\glossitem\undefined
\usepackage[portuguese]{gloss}

%%%%%%%%%%%%%%%%%%%
%%% Miscellaneous %
%%%%%%%%%%%%%%%%%%%

\usepackage{amsmath}
\usepackage[backend=biber,indent,style=abnt]{biblatex}
\usepackage{calc}
\usepackage{caption}
\usepackage[brazilian]{cleveref}
\usepackage{color}
\usepackage[listings,minted,skins,xparse]{tcolorbox}
\usepackage{csquotes}
\usepackage{graphicx}
\usepackage{minted}
\usepackage{palatino}
\usepackage{paralist}
\usepackage{tikz}
\usepackage{xspace}

%%%%%%%%%%%%%%%%%%
%% Handy Aliases %
%%%%%%%%%%%%%%%%%%

\newcommand{\treesitter}{\textit{Tree-Sitter}\xspace}
\newcommand{\witchcooking}{\textit{Witch Cooking}\xspace}

%%%%%%%%%%%%%%%%%%
%% Configuration %
%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% ABNT's NBR 14724 Metrics Compliance %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\setlength{\parindent}{1.3cm}
\setlength{\parskip}{0.2cm}

%%%%%%%%%%%%%
%%% abntex2 %
%%%%%%%%%%%%%

\renewcommand{\ABNTEXchapterfont}{\fontseries{b}}
\renewcommand{\apendicename}{Apêndice}
\renewcommand{\folhaderostoname}{Folha de Rosto}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Cover & Title Page Info %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\titulo
  {%
    \witchcooking: Formatação de Código via Linguagem de Consulta do
    \treesitter}
\autor{Átila Gama Silva}
\local{Irecê}
\data{\the\year}
\orientador{Rafael Xavier}
\instituicao
  {Instituto Federal de Educação, Ciência e Tecnologia da Bahia – Campus Irecê}
\tipotrabalho{Trabalho de Conclusão de Curso}
\preambulo
  {%
    \textit{Trabalho de Conclusão de Curso} apresentado ao
    \textit
      {%
        Curso Técnico em Análise e Desenvolvimento de Sistemas do Instituto
        Federal de Educação, Ciência e Tecnologia da Bahia – Campus Irecê}%
    , como requisito parcial para obtenção do diploma de
    \textit{Técnico em Análise e Desenvolvimento de Sistemas}, mediante a
    orientação do professor \imprimirorientador.}

%%%%%%%%%%%%%%%%%%%
%%%% IFBA's Cover %
%%%%%%%%%%%%%%%%%%%

\renewcommand
  {\imprimircapa}
  {%
    \begin{capa}
      \ABNTEXchapterfont
      \ABNTEXsectionfontsize
      \center
      \includegraphics[width=\textwidth]{ifba-irece-logo.png}
      \par\vfill\imprimirautor
      \par\vfill{\ABNTEXchapterfontsize\imprimirtitulo}
      \vfill\vfill
      \par\imprimirlocal\break\imprimirdata
    \end{capa}}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%% IFBA's Title Page %
%%%%%%%%%%%%%%%%%%%%%%%%

\makeatletter
\renewcommand
  {\folhaderostocontent}
  {%
    \begin{center}
      \ABNTEXchapterfont
      \ABNTEXsectionfontsize
      \imprimirautor
      \par\vfill\vfill{\ABNTEXchapterfontsize\imprimirtitulo}
      \vfill
      {%
        \normalsize
        \mdseries
        \hspace{.45\textwidth}
        \begin{minipage}{.5\textwidth}
          \SingleSpacing
          \imprimirpreambulo
        \end{minipage}}
      \vfill\vfill
      \imprimirlocal\break\imprimirdata
    \end{center}}
\makeatother

%%%%%%%%%%
%%%% TOC %
%%%%%%%%%%

\setlength{\cftlastnumwidth}{\cftsectionnumwidth}

\cftsetindents{part}{0em}{\cftlastnumwidth}
\cftsetindents{chapter}{0em}{\cftlastnumwidth}
\cftsetindents{section}{0em}{\cftlastnumwidth}
\cftsetindents{subsection}{0em}{\cftlastnumwidth}
\cftsetindents{subsubsection}{0em}{\cftlastnumwidth}
\cftsetindents{paragraph}{0em}{\cftlastnumwidth}
\cftsetindents{subparagraph}{0em}{\cftlastnumwidth}

\renewcommand
  {\tocprintchapter}
  {\addtocontents{toc}{\cftsetindents{chapter}{0em}{\cftlastnumwidth}}}

\renewcommand
  {\tocinnonumchapter}
  {%
    \addtocontents{toc}{\cftsetindents{chapter}{\cftlastnumwidth}{0em}}
    \cftinserthook{toc}{A}}

\renewcommand
  {\tocprintchapternonum}
  {\addtocontents{toc}{\cftsetindents{chapter}{\cftlastnumwidth}{0em}}}

\renewcommand
  {\tocpartapendices}
  {%
    \addtocontents{toc}{\cftsetindents{part}{\cftlastnumwidth}{0em}}
    \cftinserthook{toc}{A}}

\renewcommand
  {\tocpartanexos}
  {%
    \addtocontents{toc}{\cftsetindents{part}{\cftlastnumwidth}{0em}}
    \cftinserthook{toc}{A}}

\renewcommand{\cftchapterfont}{\bfseries}
\renewcommand{\cftchapterpagefont}{\cftchapterfont}
\renewcommand{\cftsectionfont}{\cftchapterfont\ABNTEXfontereduzida}
\renewcommand{\cftsectionpagefont}{\cftsectionfont}

\renewcommand{\postextual}{}

%%%%%%%%%%%%%%%%%%
%%% Bibliography %
%%%%%%%%%%%%%%%%%%

\addbibresource{references.bib}

%%%%%%%%%%%%%%
%%% cleveref %
%%%%%%%%%%%%%%

\crefname{listing}{trecho de código}{trechos de código}

%%%%%%%%%%%%%%%%%%%
%%% Code Snippets %
%%%%%%%%%%%%%%%%%%%

\renewcommand{\theFancyVerbLine}{\ttfamily\arabic{FancyVerbLine}}

\definecolor{codehighlight}{RGB}{240,240,170}
\newcommand{\hi}[1]{\colorbox{codehighlight}{#1}}
\setminted{highlightcolor={codehighlight},spacecolor=gray!50}

\NewTotalTCBox
  {\codesnippetinline}
  {O{text}vO{}}
  { bottom=0pt,
    enhanced,
    frame hidden,
    left=0pt,
    on line,
    right=0pt,
    sharp corners,
    top=0pt}
  {\mintinline[#3]{#1}{#2}}%

\NewTCBListing
  [auto counter,list inside=codesnippets]
  {codesnippet}
  {sO{text}mm!O{}!O{}}
  { enhanced,
    center title,
    coltitle=black,
    fonttitle=\ABNTEXfontereduzida,
    frame hidden,
    label={snippet:#2:#4},
    label type=listing,
    list entry={Trecho de Código \thetcbcounter{} -- #3},
    listing engine=minted,
    listing only,
    minted language=#2,
    minted options=
      { autogobble,
        breakanywhere,
        breakanywheresymbolpre={},
        breakautoindent=false,
        breaklines,
        breaksymbol={},
        linenos,
        xleftmargin=\IfBooleanTF{#1}{1.5}{1}em,
        #5},
    overlay=
      {%
        \begin{tcbclipinterior}
          \fill[gray!25]
          (frame.south west)
          rectangle
          ([xshift=\IfBooleanTF{#1}{2.5}{2}em]frame.north west);
        \end{tcbclipinterior}},
    sharp corners,
    title={Trecho de Código \thetcbcounter{} -- #3},
    #6}

%%%%%%%%%%%%%
%%% Figures %
%%%%%%%%%%%%%

\NewTotalTCBox
  [auto counter,list inside=figureswrapper]
  {\figurewrapper}
  {mmO{}m}
  { enhanced,
    center title,
    coltitle=black,
    fonttitle=\ABNTEXfontereduzida,
    frame hidden,
    label={figure:#2},
    label type=figure,
    list entry={Figura \thetcbcounter{} -- #1},
    sharp corners,
    title={Figura \thetcbcounter{} -- #1},
    #3}
  {#4}

%%%%%%%%%%%
%%% Float %
%%%%%%%%%%%

\makeatletter
\setlength{\@fptop}{5pt}
\makeatother

%%%%%%%%%%%%%%
%%% Glossary %
%%%%%%%%%%%%%%

\setglosslabel{\bfseries#2\ifglossshort{ (#3)}{}}
\renewenvironment
  {thegloss}
  {%
    \chapter*{\glossname}
    \markboth{\glossname}{\glossname}
    \addcontentsline{toc}{chapter}{\glossname}}
  {\stopglosslist}
\makegloss

%%%%%%%%%%%%%%
%%% Paralist %
%%%%%%%%%%%%%%

\setdefaultenum{(I)}{(A)}{}{}

%%%%%%%%%
%%% PDF %
%%%%%%%%%

\definecolor{blue}{RGB}{41,5,195}
\makeatletter
\hypersetup
  { pdftitle={\@title},
    pdfauthor={\@author},
    pdfsubject=
      {%
        \witchcooking: Formatação de Código via Linguagem de Consulta do
        \treesitter},
    pdfcreator={\LaTeX with \abnTeX},
    pdfkeywords=
      {formatação de código}
      {\textit{prettyprint}}
      {formatação personalizada}
      {\treesitter}
      {linguagem de consulta},
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    filecolor=magenta,
    urlcolor=blue,
    bookmarksdepth=4}
\makeatother

%%%%%%%%%%
%%% TikZ %
%%%%%%%%%%

\usetikzlibrary{calc,decorations.pathmorphing,positioning}

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\begin{document}
  \selectlanguage{brazil}
  \frenchspacing

  %%%%%%%%%%%
  % Lengths %
  %%%%%%%%%%%

  %%%%%%%%%%%%%%
  %% Half Part %
  %%%%%%%%%%%%%%

  \newlength{\halfpart}
  \setlength{\halfpart}{.5\textwidth - .5em}

  %%%%%%%%%%%%%%%%%%%%%
  %% Text Width Parts %
  %%%%%%%%%%%%%%%%%%%%%

  \newlength{\halftextwidthpart}
  \setlength{\halftextwidthpart}{.5\textwidth}
  \newlength{\halftextwidthcounterpart}
  \setlength{\halftextwidthcounterpart}{.5\textwidth - 1em}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %% Text Width Plus Two em Parts %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \newlength{\halftextwidthplustwoempart}
  \setlength{\halftextwidthplustwoempart}{.5\textwidth + 2em}
  \newlength{\halftextwidthplustwoemcounterpart}
  \setlength{\halftextwidthplustwoemcounterpart}{.5\textwidth - 3em}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %% Text Width Plus Five em Parts %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \newlength{\halftextwidthplusfiveempart}
  \setlength{\halftextwidthplusfiveempart}{.5\textwidth + 5em}
  \newlength{\halftextwidthplusfiveemcounterpart}
  \setlength{\halftextwidthplusfiveemcounterpart}{.5\textwidth - 6em}

  %%%%%%%%%%%%%%
  % Pretextual %
  %%%%%%%%%%%%%%

  \imprimircapa
  \imprimirfolhaderosto

  %%%%%%%%%%%%
  % Abstract %
  %%%%%%%%%%%%

  \setlength{\absparsep}{18pt}

  \begin{resumo}
    A formatação de código é fundamental no desenvolvimento de software,
    permitindo estabelecer aspectos desejados como a padronização e
    legibilidade do código, que impactam positivamente o ciclo de vida do
    software. Em ambientes de desenvolvimento modernos, é comum o uso de
    ferramentas para automatizar a formatação de código. No entanto, essas
    ferramentas geralmente apresentam limitações no número de linguagens
    suportadas, nas opções de configuração e não permitem a definição de
    estilos de formatação personalizados. Visando superar ou reduzir as
    limitações frequentemente encontradas nas ferramentas convencionais de
    formatação, neste trabalho é apresentado o \witchcooking, um software
    prototípico que tem como objetivos:
    \begin{inparaenum}
      \item abranger uma gama de linguagens de programação, além de
      \item permitir que o usuário defina seus próprios estilos de formatação.
    \end{inparaenum}

    \noindent
    \textbf{Palavras-chave}:
    formatação de código;
    \textit{prettyprint};
    formatação personalizada;
    \treesitter;
    linguagem de consulta.
  \end{resumo}

  %%%%%%%%%%%%%%%%%%%
  % List of Figures %
  %%%%%%%%%%%%%%%%%%%

  \newcommand{\figureswrappername}{Lista de Ilustrações}
  \begin{KeepFromToc}
    \pdfbookmark[0]{\figureswrappername}{figureswrapper}
    \tcblistof[\chapter*]{figureswrapper}{\figureswrappername}
  \end{KeepFromToc}
  \cleardoublepage

  %%%%%%%%%%%%%%%%%%%%%%%%%
  % List of Code Snippets %
  %%%%%%%%%%%%%%%%%%%%%%%%%

  \newcommand{\codesnippetsname}{Lista de Trechos de Código}
  \begin{KeepFromToc}
    \pdfbookmark[0]{\codesnippetsname}{codesnippets}
    \tcblistof[\chapter*]{codesnippets}{\codesnippetsname}
  \end{KeepFromToc}
  \cleardoublepage

  %%%%%%%%%%%%%%%%%%%%%
  % Table of Contents %
  %%%%%%%%%%%%%%%%%%%%%

  \pdfbookmark[0]{\contentsname}{toc}
  \tableofcontents*
  \cleardoublepage

  %%%%%%%%%%%%%%%%%%%%
  % Textual Elements %
  %%%%%%%%%%%%%%%%%%%%

  \textual

  %%%%%%%%%%%%%%%%%
  %% Introduction %
  %%%%%%%%%%%%%%%%%

  \chapter{Introdução}

  A flexibilidade presente na sintaxe de linguagens de programação permite que
  diferentes arranjos de um mesmo código compartilhem um valor sintático
  equivalente. Essa característica possibilita a formatação do código de acordo
  com aspectos desejados, como a legibilidade, que é fundamental no ciclo de
  vida do software
  \cites[546]{buse-2009-learning}[1]{oliveira-2020-evaluating}.
  Consequentemente, a formatação é frequentemente utilizada para estabelecer um
  nível satisfatório de legibilidade em bases de código.

  A formatação de código pode ser realizada manualmente pelo programador,
  embora esse processo possa ser demorado, especialmente em grandes bases de
  código, exigindo do programador um tempo que poderia ser empregado em outra
  tarefa. Além disso, a formatação manual também pode ser falha e inconsistente
  devido à suscetibilidade humana ao erro, podendo ser agravada quando há
  múltiplos programadores em uma base de código.

  Para evitar os problemas inerentes da formatação manual, é comum a utilização
  de softwares que automatizam a formatação de forma determinística, tornando o
  código padronizado e consistente. No entanto, é comum que essas ferramentas
  de formatação sejam limitadas a uma linguagem ou a uma família de linguagens
  de programação. Além disso, algumas delas são opinativas, assim restringindo
  as possibilidades de personalização pelo usuário. Finalmente, é também comum
  que essas ferramentas de formatação não permitam que o usuário defina estilos
  de formatação personalizados.

  Em ambientes de desenvolvimento modernos, além da utilização de ferramentas
  que automatizam a formatação de código, é também comum a utilização do
  \treesitter \cite{tree-sitter-2018-tree}: um sistema de análise sintática de
  código aberto que foi disponibilizado ao público geral no GitHub
  primeiramente em 2019, tendo sido inicialmente desenvolvido por Max
  Brunsfeld. Desde seu lançamento, o \treesitter tem ganhado popularidade na
  comunidade de desenvolvedores devido dentre outros motivos à:
  \begin{inparaenum}
    \item sua capacidade de suportar várias linguagens de programação; além de
    \item sua linguagem de consulta, a qual permite a realização de buscas
          complexas na árvore analisada de um código-fonte.
  \end{inparaenum}

  Visando superar ou reduzir as limitações previamente mencionadas, que são
  frequentemente presentes nas ferramentas convencionais de formatação, este
  trabalho tem como objetivo geral desenvolver um software prototípico para a
  formatação de código. A ferramenta desenvolvida, nomeada de \witchcooking
  \cite{silva-2023-witch}, tem como objetivos:
  \begin{inparaenum}
    \item abranger uma gama de linguagens de programação, além de
    \item permitir que o usuário defina seus estilos personalizados de
          formatação.
  \end{inparaenum}

  Para alcançar o objetivo geral proposto, este trabalho tem como objetivos
  específicos:
  \begin{inparaenum}
    \item apresentar e contextualizar ferramentas de formatação de código
          conceituadas, além de abordar seus métodos de formatação;
    \item conceituar, contextualizar e abordar as tecnologias do sistema
          \treesitter; e, por fim,
    \item utilizar o \treesitter para desenvolver e atender às aspirações do
          \witchcooking.
  \end{inparaenum}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %% The Source Code Formatting %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \chapter{A Formatação de Código-Fonte}

  Desde os primórdios da computação, métodos foram desenvolvidos para garantir
  que a saída impressa fosse formatada de maneira esteticamente agradável
  \apud{harris-1956-keyboard}[1]{yelland-2015-rfmt}. Esses métodos ganharam
  popularidade sob o termo \textit{``\gloss{prettyprinting}''}, que se refere à
  formatação visual de diversos tipos de conteúdo. No desenvolvimento de
  software, o \textit{prettyprinting} é conhecido como formatação de código,
  uma prática histórica e comum que envolve a adoção de convenções estilísticas
  para estruturar o código-fonte. Existem diversas terminologias utilizadas
  para se referir às ferramentas que realizam a formatação do código-fonte,
  incluindo:
  \begin{inparaenum}
    \item ``formatadores de código'', ou \textit{``code formatters''} em
          inglês;
    \item \textit{``prettyprinters''}; ou ainda
    \item \textit{``beautifiers''}.
  \end{inparaenum}

  \newsavebox\mexpressionexample
  \begin{lrbox}{\mexpressionexample}
    \codesnippetinline{car[cons[A; B]]}[fontsize=\footnotesize]
  \end{lrbox}

  \newsavebox\sexpressionexample
  \begin{lrbox}{\sexpressionexample}
    \codesnippetinline[lisp]{(car (cons A B))}[fontsize=\footnotesize]
  \end{lrbox}

  Durante as décadas de 60 e 70, a linguagem de programação LISP%
  \footnote
    { O termo ``LISP'' (acrônimo para
      \textit{``\textbf{LIS}t \textbf{P}rocessing''}) inicialmente se referia à
      linguagem de programação desenvolvida por
      \textcite{mccarthy-1960-recursive}, porém, com a disseminação de dialetos
      da linguagem, o termo também passou a ser utilizado para se referir à
      família de linguagens derivadas da original.}
  proporcionou condições favoráveis para o avanço da formatação de código
  \cite[2]{yelland-2015-new}.
  \begin{inparaenum}
    \item LISP apresentava uma sintaxe distinta e expressiva, baseada em listas
          e estruturas aninhadas delimitadas por parênteses%
          \footnote
            { Na notação original de McCarthy, eram utilizadas
              \textit{M-expressions} entre colchetes para representar
              expressões. Essas \textit{M-expressions} seriam posteriormente
              traduzidas em \textit{\gloss[Word]{sexp}s}. Por exemplo, a
              \textit{M-expression} \usebox{\mexpressionexample} seria
              equivalente à \textit{S-expression} \usebox{\sexpressionexample}.
              No entanto, assim que a linguagem LISP foi implementada, os
              programadores prontamente adotaram o uso das
              \textit{S-expressions} em vez das \textit{M-expressions},
              tornando as \textit{S-expressions} a forma predominante de
              representar a estrutura do código na linguagem.}%
          , o que tornava o código-fonte praticamente ilegível e
          incompreensível caso não fosse devidamente organizado. Além disso,
    \item LISP era \gloss{homoiconic}, ou seja, permitia a manipulação do
          código via dados da própria linguagem.
  \end{inparaenum}
  Essas duas características intrínsecas do LISP fundamentaram o surgimento de:
  \begin{inparaenum}
    \item \textit{prettyprinters} para a linguagem, visando aperfeiçoar a
          legibilidade do código-fonte escrito ou emitido; além de
    \item novas técnicas e abordagens para a formatação de código em geral.
  \end{inparaenum}
  Esses avanços contribuíram significativamente para o conhecimento e o
  aprimoramento de práticas de formatação de código em trabalhos subsequentes.

  Em 1967, Bill Gosper desenvolveu o \textit{GRINDEF} (acrônimo para
  \textit
    {%
      ``\textbf{GRIND}%
      \footnote
        { O termo \textit{``grind''} era utilizado em alguns círculos de LISP
          como sinônimo para \textit{prettyprinters}.}
      \textbf{F}unction''}%
  ): considerado o primeiro \textit{prettyprinter} a mensurar o tamanho das
  linhas e ter ciência de sua localização no arquivo
  \cites{gosper-2023-twubblesome}{griesemer-2022-cultural}. Essa ferramenta
  implementava o algoritmo \textit{recursive re-predictor}, que, como descrito
  por \textcite{goldstein-1973-pretty}, percorria a árvore de nós representando
  as listas e imprimia os nós considerando seus tamanhos e a quantidade máxima
  de caracteres que ainda poderiam ser inseridos em uma linha.

  Posteriormente, \textcite{hearn-1979-one} propuseram um algoritmo mais
  elaborado para \textit{prettyprinting} que utilizava um par de corrotinas%
  \footnote
    { Na obra, os autores enfatizam que a implementação com o uso de corrotinas
      é tão simples que poderia ser simulada -- sem grandes dificuldades -- em
      linguagens que não possuíam suporte nativo para corrotinas
      \cite[53]{hearn-1979-one}.}%
  :
  \begin{inparaenum}
    \item uma responsável por produzir uma sequência de caracteres que
          representavam o programa sendo impresso; e
    \item outra responsável por decidir como esses caracteres seriam exibidos.
  \end{inparaenum}
  Essas corrotinas se comunicavam por meio de um buffer \gloss{fifo},
  permitindo que as decisões de formatação fossem adiadas até que houvesse
  informações suficientes disponíveis para tomá-las com confiabilidade.

  No ano seguinte, \textcite{oppen-1980-prettyprinting} apresentou em sua
  influente obra, intitulada \textit{``Prettyprinting''}, um algoritmo inovador
  de formatação de código-fonte. Embora apresentasse semelhanças ao algoritmo
  proposto por \textcite{hearn-1979-one}, destacava-se por sua capacidade de
  formatar código derivado de qualquer linguagem de programação. Para realizar
  essa tarefa, o algoritmo necessitava que o código-fonte fosse anotado com
  espaços em branco%
  \footnote
    { Quebras de linha, avanços de formulário e alimentações de linha também
      eram tratados como espaços em branco pelo algoritmo.}
  e delimitadores especiais para marcar o início e fim de blocos logicamente
  contíguos. Assim, o código a ser fornecido ao algoritmo precisaria ser
  processado por uma ferramenta intermediária capaz de compreender a sintaxe da
  linguagem e fornecer um código anotado de forma adequada, permitindo que o
  algoritmo realizasse a formatação apropriada.

  Recentemente, tem se tornado cada vez mais evidente a crescente relevância
  dos softwares opinativos \cite{eccles-2015-rise}, também conhecidos em inglês
  como \textit{\gloss{opinionated} softwares}. Esses softwares preestabelecem
  práticas estritivas, visando deliberadamente frustrar ou dificultar práticas
  destoantes \cite{lance-2021-about}. Similarmente, os \textit{prettyprinters}
  primitivos, tais como o SOAP \cite{scowen-1971-soap}, eram naturalmente
  restritivos devido à simplicidade e às limitações dos algoritmos de
  formatação existentes. Conforme mencionado, à medida que os algoritmos de
  formatação de código-fonte eram aprimorados, tornando-se mais robustos e
  sofisticados, os \textit{prettyprinters} passaram a proporcionar mais
  personalizações aos usuários. No entanto, atualmente, a abordagem opinativa
  também tem sido adotada por softwares modernos de formatação de código-fonte
  \cites{black-2023-black}[5--6,8]{griesemer-2022-cultural}. Esses softwares
  geralmente têm como objetivos:
  \begin{inparaenum}
    \item padronizar e
    \item garantir a consistência do código; além
    \item eliminar o tempo e esforços necessários para escolher os estilos
          ideais de formatação; e, finalmente, consequentemente e
          principalmente
    \item aprimorar o ambiente de desenvolvimento colaborativo.
  \end{inparaenum}

  Um exemplo proeminente de \textit{prettyprinter} opinativo é o
  \textit{\textbf{Black}} \cite{black-2023-black}, um formatador de código
  Python, cuja logomarca parodia a da fabricante automobilística Ford, e cujo
  irônico slogan \textit{\textbf{``any color you like''}} faz alusão à famosa
  frase
  \textit
    {%
      ``any customer can have a car painted \textbf{any colour that he wants so
      long as it is black}''}
  \cite[p. 72, grifo nosso]{ford-1922-my}, dita por Henry Ford, o fundador da
  fabricante. Assim como Ford adotou uma abordagem de produção em massa na
  fabricação dos \textit{Model Ts} com uma única opção de cor para aumentar a
  eficiência \cite{ford-1922-my}, o \textit{Black} segue um princípio análogo.
  Ao impor um estilo estrito de formatação, minimizando o espaço para
  personalização ou preferências individuais, o \textit{Black} oferece
  velocidade, determinismo, além de economia de tempo e esforços para questões
  mais importantes \cite{black-2023-black}.

  Sumarizando, desenvolver um \textit{prettyprinter} não é uma tarefa simples
  \cite[55]{hughes-1995-design}. Durante o processo de formatação, é necessário
  \begin{inparaenum}
    \item ter conhecimento das estruturas gramaticais da linguagem específica
          em questão. Além disso, o objetivo do \textit{prettyprinter} é
    \item \label{item:format} formatar o código de maneira otimizada e
          agradável para o leitor \cite[55]{hughes-1995-design}, levando em
          consideração as melhores práticas de formatação. Em alguns casos,
          também é importante
    \item permitir que o usuário possa optar por estilos de formatação que
          atenda às suas preferências individuais. Adicionalmente, as sintaxes
          das linguagens de programação costumam ser flexíveis em relação à
          estruturação do código-fonte. Assim, para atender o
          \cref{item:format}, geralmente é necessário
    \item utilizar algoritmos que calculem o layout mais adequado de acordo com
          o contexto
          \cites
            [12]{jasper-2023-clang}
            {goldstein-1973-pretty}
            {hughes-1995-design}
            {yelland-2015-new}.
  \end{inparaenum}
  Fatalmente, essas características essenciais de um \textit{prettyprinter}
  normalmente o restringem a uma linguagem específica ou, em alguns casos, a
  uma família de linguagens que compartilham semelhanças sintáticas ou
  estruturais.

  %%%%%%%%%%%%%%%%%%%%%%%%%%%
  %% The Tree-Sitter System %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%

  \chapter{O Sistema \treesitter}
  \label{chapter:tree-sitter}

  O \treesitter é um sistema multilíngue de análise sintática para ferramentas
  de programação inicialmente desenvolvido como um projeto secundário por Max
  Brunsfeld. Como relatado pelo próprio autor \cite{github-2017-tree}, o
  \treesitter surgiu como uma tentativa de solucionar problemas presentes nas
  ferramentas de análise sintática da época. Mais especificamente, o sistema
  tinha como objetivos:
  \begin{inparaenum}
    \item ser utilizado no ambiente de desenvolvimento para produzir árvores de
          sintaxe a partir da análise de códigos escritos em várias linguagens;
    \item implementar a análise incremental, permitindo a atualização da árvore
          de sintaxe em tempo real;
    \item expor através da árvore de sintaxe os nós representando suas
          construções gramaticais no código (e.g., classes, funções,
          declarações, etc.), diferentemente das ferramentas contemporâneas,
          que utilizavam uma abordagem simplística baseada em expressões
          regulares; e, por fim,
    \item ser livre de dependências, assim beneficiando sua adoção e
          aplicabilidade.
  \end{inparaenum}

  Além das funcionalidades previamente mencionadas presentes no \treesitter, o
  sistema também conta uma ferramenta de linha de comando que pode ser
  utilizada para gerar \textit{\gloss{parser}s} para uma linguagem a partir de
  sua gramática. A gramática é definida via a linguagem de programação
  JavaScript, a qual:
  \begin{inparaenum}
    \item foi eleita 15 vezes seguidas pela
          \textit{Stack Overflow Developer Survey}
          \cite{stack-overflow-2022-stack} como a linguagem de programação mais
          comumente usada; além de
    \item ser amplamente considerada pela comunidade de programadores como uma
          das linguagens mais fáceis de aprender e programar
          \cites{berkeley-2023-11}{goel-2023-how}{w3schools-2023-javascript}.
  \end{inparaenum}
  A ferramenta de geração de \textit{parsers} também disponibiliza funções
  preestabelecidas para permitir a criação de gramáticas com diferentes níveis
  de complexidade. Não é surpreendente que, devido a essas características e
  facilidades presentes na criação de \textit{parsers}, exista uma variedade de
  linguagens de programação e formatos de arquivos -- variando de linguagens
  com sintaxes complexas, como C++ e Perl, a formatos de arquivos mais
  específicos, como \codesnippetinline{.vhs} e \codesnippetinline{.rasi} --, os
  quais têm parsers gerados pelo \treesitter e, consequentemente, são
  suportados pelo sistema.

  Na análise de código, é comum realizar tarefas que envolvem a busca de
  padrões na árvore sintática. Para isso, o \treesitter oferece uma pequena
  linguagem de consulta declarativa que é capaz de expressar esses padrões por
  meio de \textit{\gloss[Word]{sexp}s} e buscar correspondências. A linguagem
  de consulta suporta operadores que permitem:
  \begin{inparaenum}
    \item a captura de nós;
    \item a quantificação de nós, análoga às expressões regulares;
    \item o agrupamento de nós;
    \item as alternâncias de nós;
    \item o uso de \textit{\gloss{wildcard}s}; e
    \item a ordenação de nós.
  \end{inparaenum}
  Adicionalmente, é permitido o uso de predicados -- funções arbitrárias
  geralmente utilizadas para filtrar nós ou realizar verificações mais
  complexas durante a busca de padrões --, sejam eles \textit{\gloss{builtin}s}
  ou estendidos por meio de uma API.

  Um exemplo da relevância e utilidade da linguagem de consulta é o plugin
  \textit{nvim-treesitter} \cite{nvim-treesitter-2023-nvim}, que é
  frequentemente utilizado no editor \textit{Neovim}
  \cite{neovim-2023-hyperextensible}. Esse plugin utiliza a linguagem de
  consulta para definir diferentes recursos, tais como:
  \begin{inparaenum}
    \item \textit{\gloss{code-folding}}, que permite ocultar blocos de código;
    \item highlights, que realçam a sintaxe do código;
    \item indentações, que definem a estrutura do código;
    \item injeções, que permitem adicionar novas sintaxes a arquivos
          existentes; além de
    \item captura de nós correspondentes a construções gramaticais (e.g.,
          funções, classes, métodos, etc.), os quais são frequentemente
          utilizados em rotinas de programação tais como a remoção e navegação
          de código.
  \end{inparaenum}

  Em resumo, o sistema \treesitter se mostra uma solução inovadora e eficiente
  para a análise sintática de códigos em diversas linguagens de programação,
  com uma abordagem diferenciada e sofisticada que possibilita a atualização em
  tempo real da árvore sintática e a identificação precisa das construções
  gramaticais presentes no código. Além disso, a ferramenta de linha de comando
  disponível no sistema facilita a geração de parsers a partir de gramáticas
  definidas em JavaScript, o que torna o processo mais acessível e
  personalizável para os programadores. Finalmente, a linguagem de consulta
  declarativa oferecida pelo \treesitter se mostra uma importante
  \textit{\gloss{feature}}, sendo utilizada em diversos plugins de editores de
  código para realizar tarefas variadas e sofisticadas, contribuindo
  significativamente no ambiente de desenvolvimento.

  %%%%%%%%%%%%%%%%%%%%%%
  %% The Witch Cooking %
  %%%%%%%%%%%%%%%%%%%%%%

  \chapter{O \witchcooking}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Motivations and Purposes %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Motivações e Propósitos}

  As motivações para o desenvolvimento do \witchcooking surgiram das
  dificuldades enfrentadas pelo autor ao estudar estilos de formatação de
  código-fonte em diversas linguagens de programação com as quais ele
  trabalhava. O estudo envolvia a exploração e análise tanto de estilos
  convencionais%
  \footnote
    { Neste trabalho, são considerados convencionais os estilos de formatação
      abordados nas páginas \textit{Indentation style} e
      \textit{Programming style} da Wikipédia.
      \cites{wiki-2023-indentation}{wiki-2023-programming}}%
  , dos quais muitos eram amplamente adotados, quanto de estilos
  não convencionais. Durante a análise dos estilos convencionais de formatação,
  \begin{inparaenum}
    \item era imprescindível recorrer a diferentes \textit{prettyprinters},
    \item cada um com suas próprias configurações e níveis de suporte para
          esses estilos. Por outro lado, durante a análise dos estilos
          não convencionais,
    \item a aplicação manual era inevitável, consumindo consideravelmente tempo
          e esforço.
  \end{inparaenum}

  Tendo em vista
  \begin{inparaenum}
    \item as dificuldades mencionadas anteriormente, além da
    \item complexidade envolvida no \textit{prettyprinting} --
    \item agravada pela proposta de formatação multilíngue
  \end{inparaenum}
  --, o \witchcooking foi concebido como um software de linha de comando --
  de natureza prototípica -- para a formatação de código-fonte. A ferramenta
  elaborada tem como objetivos:
  \begin{inparaenum}
    \item abranger uma gama de linguagens de programação e
    \item permitir que o usuário defina seus próprios estilos de formatação
          de código-fonte.
  \end{inparaenum}

  %%%%%%%%%%%
  %%% Usage %
  %%%%%%%%%%%

  \section{Usagem}
  \label{section:usage}

  O \witchcooking apresenta a seguinte usagem
  \codesnippetinline{cook [-l LANG] -q QUERY [SRC]}%
  , onde:
  \begin{inparaenum}
    \item \codesnippetinline{cook} é o nome do executável,
    \item \codesnippetinline{[-l LANG]} é uma opção para explicitar a linguagem
          do código-fonte a ser formatado,
    \item \codesnippetinline{-q QUERY} é utilizado para definir o caminho para
          o arquivo -- escrito na linguagem de consulta do \treesitter{} -- no
          qual as instruções de formatação estão definidas, e
    \item \codesnippetinline{[SRC]} é um argumento opcional para especificar o
          caminho para o arquivo a ser formatado.
  \end{inparaenum}
  Quando \codesnippetinline{[SRC]} é provido e \codesnippetinline{[-l LANG]} é
  omitido, o software tentará inferir uma linguagem conforme a extensão do nome
  do arquivo. Por outro lado, quando \codesnippetinline{[SRC]} é omitido, o
  código-fonte a ser formatado deve ser provido via \textit{\gloss{pipeline}},
  e a sua linguagem deve ser explicitada via \codesnippetinline{[-l LANG]}. Em
  alinhamento com sua natureza experimental, o \witchcooking proporciona o
  código-fonte formatado resultante como saída, sem modificar o conteúdo
  original, efetivamente estabelecendo uma formatação segura.

  %%%%%%%%%%%%%%%
  %%% Materials %
  %%%%%%%%%%%%%%%

  \section{Materiais}

  O \witchcooking foi programado em Rust \cite{rust-2023-rust}, que é uma
  linguagem amplamente reconhecida na comunidade de programadores
  \cite{stack-overflow-2023-stack}. Dentre os motivos que levaram à escolha
  dessa linguagem para o desenvolvimento, destacam-se:
  \begin{inparaenum}
    \item seu gerenciamento de memória seguro%
          \footnote
            { Embora Rust não apresente \textit{\gloss{garbage-collection}} --
              o que contribui significativamente para o desempenho --, a
              linguagem emprega \textit{features} e conceitos como
              \textit{borrow checker}, \textit{ownership} e \textit{lifetime},
              garantindo um gerenciamento de memória seguro. Isso é
              especialmente relevante em linguagens de alto desempenho que não
              possuem coleta de lixo (e.g., C e C++). Estudos estimam que,
              nesse contexto, pelo menos 65\% das vulnerabilidades de segurança
              sejam causadas por falta de segurança no gerenciamento de memória
              \cite{gaynor-2020-what}.}
          \cite[3]{nsa-2022-software};
    \item seu excelente desempenho, a par às linguagens C e C++;
    \item seus recursos de linguagens modernas, incluindo
          \begin{inparaenum}
            \item expressividade,
            \item \textit{\gloss{zero-cost-abs}},
            \item correspondência de padrões,
            \item \textit{closures},
            \item macros, etc.;
          \end{inparaenum}
    \item seu suporte a múltiplas plataformas; além de
    \item seu ecossistema de desenvolvimento fértil, que oferece
          \begin{inparaenum}
            \item uma ampla variedade de bibliotecas,
            \item \textit{Cargo} \cite{rust-2023-cargo}, o gerenciador de
                  pacotes, além do
            \item \textit{rust-analyzer} \cite{rust-analyzer-2023-rust}, uma
                  implementação do \textit{Language Server Protocol} (LSP) para
                  a linguagem.
          \end{inparaenum}
  \end{inparaenum}

  Para atender a seus objetivos, o \witchcooking foi desenvolvido com base na
  biblioteca \treesitter \cite{tree-sitter-2018-tree}, a qual:
  \begin{inparaenum}
    \item suporta uma ampla variedade de linguagens de programação e formatos
          de arquivos, além de
    \item possuir uma linguagem de consulta versátil e extensível que, dentre
          outras características, permite
          \begin{inparaenum}
            \item a realização de buscas complexas na árvore de sintaxe
                  analisada de um código-fonte, bem como
            \item a adição de predicados personalizados.
          \end{inparaenum}
  \end{inparaenum}

  Para escrever o código do \witchcooking, foi utilizado o editor de texto
  \textit{Neovim} \cite{neovim-2023-hyperextensible}, com configurações
  personalizadas \cite{silva-2023-uma}. Essas configurações possibilitaram a
  integração com o \textit{rust-analyzer}, o que resultou em melhorias
  significativas na experiência de programação. Dentre os plugins utilizados na
  configuração, destacam-se:
  \begin{inparaenum}
    \item o \textit{nvim-treesitter} \cite{nvim-treesitter-2023-nvim}, que
          permitiu a integração com o \treesitter; além do
    \item \textit{playground} \cite{nvim-treesitter-2023-playground}, que
          disponibilizou ferramentas para uma melhor compreensão do \treesitter
          e de sua linguagem de consulta.
  \end{inparaenum}

  %%%%%%%%%%%%%
  %%% Methods %
  %%%%%%%%%%%%%

  \section{Métodos}

  Embora o \treesitter não tenha sido originalmente projetado para formatação
  de código-fonte, o autor deste trabalho identificou o potencial da
  biblioteca, particularmente em relação à sua linguagem de consulta, que --
  como já ressaltado -- é extensível. Assim, para permitir a formatação
  instruída, o \witchcooking baseou-se na extensão e disponibilização de
  predicados designados a executar operações específicas de formatação. Em
  outras palavras, a concepção do autor era que a formatação ocorresse conforme
  a aplicação dos predicados estendidos em padrões especificados no arquivo de
  instruções, escrito na linguagem de consulta do \treesitter.

  Devido à natureza prototípica do software desenvolvido, foi adotada uma
  abordagem multifacetada neste trabalho. Inicialmente, foi conduzida
  \begin{inparaenum}
    \item uma pesquisa bibliográfica que abrangeu termos-chave como:
          \begin{inparaenum}
            \item \textit{``code formatting''},
            \item \textit{``Tree-Sitter''},
            \item \textit{``programming style''}, e
            \item \textit{``style guide''}.
          \end{inparaenum}
          Complementarmente, foi feita
    \item uma pesquisa documental, que fundamentou a compreensão das
          tecnologias e bibliotecas -- em especial, o \treesitter{} --
          utilizadas no desenvolvimento do \witchcooking.

          À medida que se aprofundou o conhecimento sobre o \treesitter, foram
          incorporados elementos de
    \item uma pesquisa experimental com o objetivo de explorar a aplicação da
          biblioteca como base para o algoritmo de formatação de código-fonte.
          Similarmente, foram integrados elementos de
    \item um estudo de caso com o propósito de analisar a eficácia do software
          desenvolvido.
  \end{inparaenum}
  Essa abordagem metodológica se caracteriza como predominantemente
  qualitativa, de natureza básica e orientada por objetivos exploratórios.

  %%%%%%%%%%%%%%%%%%%%
  %%% Making Queries %
  %%%%%%%%%%%%%%%%%%%%

  \section{Fazendo Consultas}

  Como mencionado na \cref{section:usage}, o \witchcooking formata o
  código-fonte conforme as instruções presentes no arquivo submetido via
  \codesnippetinline{-q QUERY}, o qual é escrito na linguagem de consulta do
  \treesitter. Devido à importância fundamental desempenhada por essa linguagem
  na ferramenta, é essencial possuir um conhecimento básico sobre o seu
  funcionamento. Portanto, nesta seção, será abordado superficialmente o
  funcionamento da linguagem de consulta do \treesitter, permitindo assim uma
  melhor compreensão da base em que o \witchcooking foi desenvolvido.

  Como abordado no \cref{chapter:tree-sitter}, a linguagem de consulta do
  \treesitter foi originalmente concebida para buscar padrões na árvore
  sintática via:
  \begin{inparaenum}
    \item definição de padrões de correspondência e
    \item aplicação de predicados.
  \end{inparaenum}
  Os predicados disponibilizados nativamente pelo \treesitter são agnósticos
  quanto à linguagem de programação utilizada. Por outro lado, os padrões de
  correspondência variam de acordo com a linguagem devido às suas construções
  gramaticais específicas, que são posteriormente traduzidas como nós na árvore
  de sintaxe analisada.

  Por exemplo, considere os \cref{snippet:c:add-two,snippet:rust:add-two},
  escritos nas linguagens de programação C e Rust, respectivamente. Embora
  ambos desempenhem papéis idênticos -- i.e., definem uma função que retorna a
  soma do parâmetro \codesnippetinline{x} com 2 --, suas árvores de sintaxe
  analisadas -- apresentadas respectivamente nos
  \cref{snippet:text:tree:c:add-two,snippet:text:tree:rust:add-two} -- exibem
  diferenças significativas. Portanto, para buscar a correspondência do trecho
  em que o parâmetro \textit{x} é definido em ambos os códigos (i.e.,
  \codesnippetinline
    [c]
    $int add_two(|\colorbox{codehighlight}{int x}|) {$
    [escapeinside=||]
  e
  \codesnippetinline
    [rust]
    $fn add_two(|\colorbox{codehighlight}{x: i32}|) -> i32 {$
    [escapeinside=||]%
  ), são necessárias consultas distintas, apresentadas pelos
  \cref{snippet:scheme:c:param-query,snippet:scheme:rust:param-query}.

  Dado que os padrões correspondem a qualquer uma de suas ocorrências, é
  importante garantir maior especificidade em sua definição. Isso pode ser
  obtido por meio de:
  \begin{inparaenum}
    \item especificação de campos,
    \item especificação de nós anônimos e
    \item aplicação de predicados.
  \end{inparaenum}
  Para ilustrar, ao aplicar a consulta apresentada no
  \cref{snippet:scheme:c:param-query} ao seguinte código em linha
  \codesnippetinline[c]{int add(int x, int y);}, obtêm-se duas
  correspondências, como destacadas no seguinte trecho:
  \codesnippetinline[c]{int add(|\hi{int x}, \hi{int y}|);}[escapeinside=||].
  Logo, para corresponder somente ao parâmetro \codesnippetinline{x}, deve-se
  utilizar uma consulta mais elaborada, conforme exemplificada no
  \cref{snippet:scheme:c:x-param-query}. Nesse trecho, é possível notar algumas
  diferenças em relação à sua versão original, que foi apresentada no
  \cref{snippet:scheme:c:param-query}.
  \begin{inparaenum}
    \item O nó \codesnippetinline{(identifier)} é capturado com o nome
          \codesnippetinline{id}, como destacado no seguinte trecho de código:
          \codesnippetinline
            [scheme]
            {declarator: |\hi{(identifier) @id}|}
            [escapeinside=||]%
          . Além disso,
    \item o predicado \codesnippetinline{eq?} é aplicado para garantir que o
          conteúdo da captura \codesnippetinline{id} corresponda à string ``x''
          o que, por consequência, impede a correspondência do parâmetro
          \codesnippetinline{y}.
  \end{inparaenum}

  Por fim, é importante ressaltar que a linguagem de consulta do \treesitter
  disponibiliza recursos adicionais \cite{tree-sitter-2023-using} que vão além
  do escopo desta seção. No entanto, as informações abordadas até então
  estabelecem uma base fundamental para compreender o funcionamento da
  linguagem de consulta e sua aplicação em conjunto com o \witchcooking na
  formatação do código-fonte.

  \noindent
  \begin{minipage}[t]{\halfpart}
    \begin
      {codesnippet}%
      [c]%
      {Função \textit{add\_two} em C}%
      {add-two}
      int add_two(int x) {
        return x + 2;
      }
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{\halfpart}
    \begin
      {codesnippet}%
      [rust]%
      {Função \textit{add\_two} em Rust}%
      {add-two}
      fn add_two(x: i32) -> i32 {
        x + 2
      }
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  \noindent
  \begin{minipage}[t]{\halftextwidthpart}
    \begin
      {codesnippet}*%
      {Árvore Sintática da Função \textit{add\_two} em C}%
      {tree:c:add-two}%
      [fontsize=\ABNTEXfontereduzida]
      function_definition
        type: primitive_type
        declarator: function_declarator
          declarator: identifier
          parameters: parameter_list
            parameter_declaration
              type: primitive_type
              declarator: identifier
        body: compound_statement
          return_statement
            binary_expression
              left: identifier
              right: number_literal
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*
      {listing}
      { \ABNTEXfontereduzida
        \textbf{Fonte:} o próprio autor.
        \\
        \textbf{Nota:} Nós anônimos foram omitidos.}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{\halftextwidthcounterpart}
    \begin
      {codesnippet}*%
      {Árvore Sintática da Função \textit{add\_two} em Rust}%
      {tree:rust:add-two}%
      [fontsize=\ABNTEXfontereduzida]
      function_item
        name: identifier
        parameters: parameters
          parameter
            pattern: identifier
            type: primitive_type
        return_type: primitive_type
        body: block
          binary_expression
            left: identifier
            right: integer_literal
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*
      {listing}
      { \ABNTEXfontereduzida
        \textbf{Fonte:} o próprio autor.
        \\
        \textbf{Nota:} Nós anônimos foram omitidos.}
  \end{minipage}

  \noindent
  \begin{minipage}[t]{\halftextwidthpart}
    \begin
      {codesnippet}*%
      [scheme]%
      {Consulta Correspondendo a um Parâmetro de Função em C}%
      {c:param-query}
      (parameter_declaration
        type: (primitive_type)
        declarator: (identifier))
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{\halftextwidthcounterpart}
    \begin
      {codesnippet}*%
      [scheme]%
      {Consulta Correspondendo a um Parâmetro de Função em Rust}%
      {rust:param-query}
      (parameter
        pattern: (identifier)
        type: (primitive_type))
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  \noindent
  \begin{minipage}[t]{\textwidth}
    \begin
      {codesnippet}*%
      [scheme]%
      {Consulta Correspondendo ao Parâmetro \textit{x} de uma Função em C}%
      {c:x-param-query}
      (parameter_declaration
        type: (primitive_type)
        declarator: (identifier) @id
        (#eq? @id "x"))
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% The Formatting Algorithm %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{O Algoritmo de Formatação}
  \label{section:fmt-algorithm}

  O \witchcooking permite a formatação de código-fonte via seu algoritmo
  fundamentado no \treesitter e sua linguagem de consulta. Esse algoritmo
  utiliza a biblioteca para gerar uma árvore de sintaxe a partir do
  código-fonte submetido pelo usuário. Adicionalmente, complementando os
  predicados \textit{builtins} do \treesitter{} -- os quais foram concebidos
  para a busca de padrões correspondentes --, o algoritmo inclui predicados
  desenvolvidos para executar procedimentos variados de formatação.
  Consequentemente, ao utilizar esses predicados nos padrões da consulta, é
  possível instruir a formatação de nós específicos da árvore de sintaxe.

  A operação do algoritmo de formatação divide-se nas etapas de:
  \begin{inparaenum}
    \item inicialização,
    \item formatação, e
    \item retorno,
  \end{inparaenum}
  como ilustrado na \cref{figure:algorithm-flowchart}.
  Durante a etapa de inicialização -- onde estruturas são instanciadas --,
  primeiramente,
  \begin{inparaenum}
    \item a árvore de sintaxe -- derivada do código-fonte submetido para
          formatação -- é analisada. Em seguida,
    \item um objeto%
          \footnote
            { Neste contexto, o termo ``objeto'' é utilizado como uma
              alternativa para descrever uma estrutura em Rust.}
          de consulta é gerado a partir do arquivo contendo as
          instruções de formatação, escrito na linguagem de consulta do
          \treesitter. Esse objeto:
          \begin{inparaenum}
            \item contém informações sobre padrões, capturas, propriedades e
                  predicados; e
            \item é posteriormente utilizado para obter as correspondências
                  dos seus padrões.
          \end{inparaenum}

          Além disso,
    \item é instanciada uma estrutura editora que contém:
          \begin{inparaenum}
            \item o texto do código-fonte em edição -- originado do código
                  submetido pelo usuário --, juntamente com
            \item um vetor de edições.
          \end{inparaenum}
          Essa estrutura é utilizada pelos predicados para realizar edições no
          código. Na sequência,
    \item é inicializado um objeto de configurações, que é futuramente
          empregado pelos predicados para obter e definir configurações em
          diferentes níveis de escopo, sejam eles globais -- i.e., abrangendo
          toda a consulta -- ou locais -- i.e., restrito a um padrão.
          Finalizando a etapa de inicialização,
    \item a estrutura de correspondências é derivada:
          \begin{inparaenum}
            \item do objeto de consulta, juntamente com
            \item a árvore analisada e
            \item o texto do código-fonte submetido.
          \end{inparaenum}
          Simplificadamente, essa estrutura pode ser descrita como um iterador
          que fornece nós que correspondem a capturas presentes em padrões
          específicos.
  \end{inparaenum}

  O processo efetivo de formatação de código-fonte inicia na segunda etapa.
  Nessa fase, a dinâmica se baseia em
  \begin{inparaenum}
    \item \label{item:pattern-loop} um \textit{\gloss{loop}} que itera sobre
          todos os padrões especificados no arquivo de instruções de
          formatação. Em cada iteração, inicialmente,
    \item é checado se o padrão é enraizado%
          \footnote
            { Na linguagem de consulta do \treesitter, embora a biblioteca não
              forneça uma definição exata, um padrão enraizado é geralmente
              caracterizado por especificar pelo menos um nó inicial para a
              correspondência, e vice-versa.}
          ou não, determinando assim se o escopo de atuação do padrão é local
          ou global, respectivamente. Em seguida,
    \item \label{item:nodes-loop} um segundo \textit{loop} percorre as coleções
          de nós capturados para cada correspondência do padrão em questão. No
          corpo dessa estrutura de repetição,
    \item são aplicadas as configurações especificadas no padrão via o
          predicado \textit{builtin} \codesnippetinline{set!}. Além disso,
    \item são aplicados os predicados gerais -- i.e., predicados
          não \textit{builtins} -- especificados no padrão em iteração.
          Pressupõe-se que esses predicados estejam dentre os providos pelo
          \witchcooking para instruir a formatação.

          Encerrando o \cref{item:nodes-loop} e, subsequentemente, o
          \cref{item:pattern-loop}, bem como a etapa de formatação como um
          todo,
    \item as configurações locais -- i.e, configurações a nível de
          correspondência -- são redefinidas para seus valores padrões. Logo em
          seguida,
    \item é interrompido o \cref{item:nodes-loop} caso o padrão em iteração não
          seja enraizado.
  \end{inparaenum}
  Por fim, na etapa de retorno, o algoritmo conclui retornando o código-fonte
  resultante do processo de formatação.

  { \centering
    \figurewrapper
      {Fluxograma do Algoritmo de Formatação}
      {algorithm-flowchart}
      { \ABNTEXfontereduzida
        \begin
          {tikzpicture}
          [node distance=1em,every node/.style={draw,inner sep=1em}]
          \node (init) {
            \begin
              {tikzpicture}
              [ every node/.style=
                  {align=center,draw,inner sep=.5em,text width=16em}]
              \node [draw=none] (label) {Inicialização};
              \node (I) [below=of label] {Analisa a árvore de sintaxe};
              \node (II) [below=of I] {Gera o objeto de consulta};
              \node (III) [below=of II] {Instancia a estrutura editora};
              \node (IV) [below=of III] {Inicializa o objeto de configurações};
              \node (V) [below=of IV] {Deriva a estrutura de correspondências};
              \draw [->] (I) -- (II);
              \draw [->] (II) -- (III);
              \draw [->] (III) -- (IV);
              \draw [->] (IV) -- (V);
            \end{tikzpicture}
          };
          \node (fmt) [below=of init] {
            \begin
              {tikzpicture}
              [ every node/.style=
                  {align=center,draw,inner sep=.5em,text width=14em}]
              \node [draw=none,text width=16em] (label) {Formatação};
              \path
                let \p1=(label.south)
                in coordinate (I-coord) at ($ (\x1-1em,\y1-1em) $);
              \node (I) at (I-coord) {Itera sobre os padrões};
              \node (II) [below=of I] {Define o escopo de atuação};
              \node
                (III)
                [below=of II]
                {Itera sobre as coleções\\de nós capturados};
              \node (IV) [below=of III] {Aplica as configurações};
              \node (V) [below=of IV] {Aplica os predicados gerais};
              \node (VI) [below=of V] {Redefine as\\configurações locais};
              \node
                (VII)
                [below=of VI]
                {Interrompe o \cref{item:nodes-loop} se o padrão é enraizado};
              \draw [->] (I) -- (II);
              \draw [->] (II) -- (III);
              \draw [->] (III) -- (IV);
              \draw [->] (IV) -- (V);
              \draw [->] (V) -- (VI);
              \draw [->] (VI) -- (VII);
              \draw [->] (VII.east) -- ++(1em,0) |- (III.east);
              \draw [->] (VII.east) -- ++(2em,0) |- (I.east);
            \end{tikzpicture}
          };
          \draw [->] (init) -- (fmt);
          \node (ret) [below=of fmt] {
            \begin
              {tikzpicture}
              [ every node/.style=
                  {align=center,draw,inner sep=.5em,text width=16em}]
              \node [draw=none] (label) {Retorno};
              \node
                (label)
                [below=of label]
                {Retorna o código-fonte formatado};
            \end{tikzpicture}
          };
          \draw [->] (fmt) -- (ret);
        \end{tikzpicture}}
    \vspace{-2ex}
    \captionof*{figure}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}}

  \clearpage

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Instructing the Formatting %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Instruindo a Formatação}
  \label{section:instructing}

  Como já enfatizado em diversas ocasiões, as instruções de formatação do
  código-fonte são especificadas no arquivo escrito na linguagem de consulta do
  \treesitter, o qual é submetido ao \witchcooking via
  \codesnippetinline{-q QUERY}. Para realizar um procedimento de formatação, é
  necessário:
  \begin{inparaenum}
    \item definir um padrão de correspondência que delimita o escopo de
          operação;
    \item capturar nós que
          \begin{inparaenum}
            \item sejam alvos do procedimento (i.e., serão formatados) ou
            \item auxiliarão nas operações;
          \end{inparaenum}
    \item opcionalmente, aplicar configurações via o predicado
          \codesnippetinline{set!}; e, por fim,
    \item aplicar os predicados estendidos pelo \witchcooking.
  \end{inparaenum}

  Uma das operações fundamentais de formatação consiste na inserção de
  espaçamento entre \textit{\gloss{token}s}. Nesse contexto, o \witchcooking
  disponibiliza o predicado \codesnippetinline{space!}. Esse predicado funciona
  da seguinte forma \codesnippetinline{(#space! [sep [lower [upper]]] a b)},
  onde
  \begin{inparaenum}
    \item \codesnippetinline{a} e \codesnippetinline{b} são duas capturas que
          se deseja separar;
    \item \codesnippetinline{sep} é uma string opcional que determina a
          sequência de caracteres utilizada para separar os nós capturados,
          sendo o caractere de espaço o valor padrão; e
    \item \codesnippetinline{lower} e \codesnippetinline{upper} são inteiros
          não negativos opcionais que definem o intervalo inclusivo para a
          não operação do espaçamento, sendo que
          \begin{inparaenum}
            \item se ambos forem especificados, o intervalo será
                  $ \left
                      [ \codesnippetinline{lower},
                        \codesnippetinline{upper}\right]$%
                  , caso contrário,
            \item se somente \codesnippetinline{lower} for especificado, o
                  intervalo resultante será
                  $\left[1, \codesnippetinline{lower}\right]$%
                  , senão,
            \item caso ambos forem ausentes, o intervalo de não operação é
                  nulo. Além disso,
            \item quando o intervalo de não operação é definido, a separação
                  dos nós é evitada se a sequência de caracteres atual entre
                  eles contiver uma quantidade de \codesnippetinline{sep} que
                  esteja dentro do intervalo especificado.
          \end{inparaenum}
  \end{inparaenum}

  Para ilustrar o funcionamento do predicado \codesnippetinline{space!},
  considere o seguinte vetor na linguagem de programação Rust, apresentado no
  seguinte trecho de código em linha: \codesnippetinline[rust]{[0,1,   2,  3]}.
  Para formatar esse vetor, de modo que cada número após uma vírgula seja
  separado por um espaço, é possível usar a consulta exibida no
  \cref{snippet:scheme:rust:vec-items-sep}. Ao formatar o vetor com essa
  consulta, é obtido \codesnippetinline[rust]{[0, 1, 2, 3]}, conforme esperado.
  No padrão presente na consulta usada para formatar o vetor, o predicado
  \codesnippetinline{space!} é chamado com a configuração de argumentos mais
  simples, que consiste em especificar apenas as capturas que devem ser
  separadas.

  \noindent
  \begin{minipage}[t]{\textwidth}
    \begin
      {codesnippet}%
      [scheme]%
      {Consulta para Separar Elementos de um Vetor em Rust}%
      {rust:vec-items-sep}
      (array_expression
        "," @comma
        . (_) @item
        (#space! @comma @item))
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  Outro exemplo típico de inserção de espaçamento usado na formatação de
  código-fonte é o espaçamento entre elementos pertencentes ao corpo de uma
  função. Nesse contexto, é comum seprar esses elementos com uma quebra de
  linha. Contudo, em certos casos, são utilizadas duas quebras de linha para
  destacar diferentes blocos de código, a fim de favorecer a compreensão do
  leitor. Para ilustrar, considere o \cref{snippet:rust:let-decl-cluster}, que
  contém dois blocos dentro de uma função. No primeiro bloco de código, é
  possível notar o arranjo da linha 3, que contém duas
  \textit{let declarations}. Para formatar o corpo da função, desaglomerando as
  \textit{let declarations} e mantendo o espaçamento que separa os blocos, é
  possível utilizar a consulta mostrada no
  \cref{snippet:scheme:rust:fn-body-items-sep}.

  \noindent
  \begin{minipage}[t]{\halftextwidthplustwoemcounterpart}
    \begin
      {codesnippet}%
      [rust]%
      {Função Com Bloco Aglomerado em Rust}%
      {let-decl-cluster}%
      [fontsize=\ABNTEXfontereduzida]
      fn x_plus_y() -> u32 {
        let x = 5; let y = 11;

        x + y
      }
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}
  \hfill
  \noindent
  \begin{minipage}[t]{\halftextwidthplustwoempart}
    \begin
      {codesnippet}%
      [scheme]%
      {Consulta para Separar Elementos do Corpo de uma Função em Rust}%
      {rust:fn-body-items-sep}%
      [fontsize=\ABNTEXfontereduzida]
      (function_item
        body: (block (_) @item . (_) @next)
        (#space! "\n" 2 @item @next))
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  Essa consulta apresenta um padrão que aplica o predicado
  \codesnippetinline{space!} com uma configuração de argumentos mais elaborada.
  Primeiramente, em adição ao \cref{snippet:scheme:rust:vec-items-sep},
  \begin{inparaenum}
    \item é especificada a string \codesnippetinline{sep} com o valor
          \codesnippetinline{"\n"}, indicando que os itens do corpo da função
          serão separados por uma quebra de linha. Além disso,
    \item é especificado o limite inferior \codesnippetinline{lower} como 2,
          resultando num intervalo de não aplicação de $\left[1, 2\right]$.
          Em termos mais simples, isso implica que itens já separados por uma
          ou duas quebras de linha não sofrerão alterações, o que, por sua vez,
          mantém a formatação dos blocos intacta.
  \end{inparaenum}

  Desta forma, ao aplicar a consulta do
  \cref{snippet:scheme:rust:fn-body-items-sep} ao
  \cref{snippet:rust:let-decl-cluster}, obtém-se o código-fonte formatado,
  conforme ilustrado no \cref{snippet:rust:bad-indent}. Embora o uso de quebras
  de linha para separar elementos do corpo da função esteja correto,
  observa-se um erro de indentação na linha 4. Isso ocorre porque o predicado
  \codesnippetinline{space!} lida com a separação dos itens de sintaxe, mas não
  controla a indentação deles. No entanto, para lidar com a indentação, é
  possível combinar os predicados \codesnippetinline{set!} e
  \codesnippetinline{indent!}, como demonstrado no
  \cref{snippet:scheme:rust:fn-body-items-sep-with-indent}.

  \noindent
  \begin{minipage}[t]{\halftextwidthplustwoemcounterpart}
    \begin
      {codesnippet}%
      [rust]%
      {Função Com Má Indentação em Rust}%
      {bad-indent}%
      [fontsize=\ABNTEXfontereduzida]
      fn x_plus_y() -> u32 {
        let x = 5;
      let y = 11;

        x + y
      }
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}
  \hfill
  \noindent
  \begin{minipage}[t]{\halftextwidthplustwoempart}
    \begin
      {codesnippet}%
      [scheme]%
      { Consulta para Separar Elementos do Corpo de uma Função Com Indentação
        em Rust}%
      {rust:fn-body-items-sep-with-indent}%
      [fontsize=\ABNTEXfontereduzida]
      (#set! indent-style "  ")

      (function_item
        body: (block (_) @item . (_) @next)
        (#space! "\n" 2 @item @next)
        (#set! @next indent-rule "+1")
        (#indent! @next))
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  Na primeira linha deste trecho, observa-se um padrão composto exclusivamente
  pelo predicado \codesnippetinline{set!}, no qual a propriedade
  \codesnippetinline{indent-style} é configurada para dois caracteres de
  espaço. Conforme discutido na \cref{section:fmt-algorithm}, a ausência de um
  nó como base para correspondência classifica esse padrão como enraizado,
  implicando que a propriedade especificada terá um efeito no escopo global.
  Simplificadamente, o trecho
  \codesnippetinline[scheme]{(#set! indent-style "  ")} estabelece que, a menos
  que a configuração \codesnippetinline{indent-style} seja sobreposta
  localmente, o estilo de indentação será caracterizado como dois espaços.

  Ainda na consulta ilustrada pelo
  \cref{snippet:scheme:rust:fn-body-items-sep-with-indent}, no padrão enraizado
  pelo nó \codesnippetinline{function_item}, começado na linha 3, podem ser
  observadas duas diferenças em relação à versão anterior, exibida no
  \cref{snippet:scheme:rust:fn-body-items-sep}. Primeiramente,
  \begin{inparaenum}
    \item na linha 6, a propriedade \codesnippetinline{indent-rule} é
          configurada com o valor \codesnippetinline{"+1"} para a captura
          \codesnippetinline{@next}. Essa configuração define que, ao indentar
          os nós capturados, deverá ser utilizado o estilo de indentação
          vigente em adição ao deslocamento dos nós pais%
          \footnote
            { Tecnicamente, o deslocamento é calculado como o índice (em bytes)
              do primeiro caractere que não seja classificado como um
              \textit{ASCII whitespace} \cite{infra-2023-ascii} presente na
              linha que inicia o pai do nó capturado.}%
          . Além disso,
    \item na próxima linha, o predicado \codesnippetinline{indent!} é aplicado,
          tomando como argumento a captura \codesnippetinline{@next}. Esse
          predicado tem como função aplicar a indentação previamente
          configurada a cada nó capturado pelos argumentos passados.
  \end{inparaenum}

  Finalmente, ao aplicar uma consulta mais sofisticada -- exemplificada no
  \cref{snippet:scheme:rust:fn-body-items-sep-with-indent} -- ao
  \cref{snippet:rust:let-decl-cluster}, obtém-se o código-fonte formatado
  conforme ilustrado no \cref{snippet:rust:proper-indent}. Nesse código,
  observa-se que:
  \begin{inparaenum}
    \item os blocos de código foram preservados, bem como
    \item as \textit{let declarations} foram desaglomeradas em suas respectivas
          linhas -- e com a devida indentação --,
  \end{inparaenum}
  atendendo às expectativas de formatação.

  \noindent
  \begin{minipage}[t]{\textwidth}
    \begin
      {codesnippet}%
      [rust]%
      {Função Com Indentação Apropriada em Rust}%
      {proper-indent}
      fn x_plus_y() -> u32 {
        let x = 5;
        let y = 11;

        x + y
      }
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  No decorrer da exemplificação do uso do predicado \codesnippetinline{space!}
  com a configuração de argumentos mais avançada, foi introduzida a
  configuração \codesnippetinline{indent-rule}. Essa configuração determina a
  regra de indentação para uma captura específica -- i.e., a designação de
  uma captura é obrigatória para essa configuração. Através do predicado
  \codesnippetinline{set!}, é possível especificar os seguintes tipos valores
  para a configuração \codesnippetinline{indent-rule}.

  Primeiramente,
  \begin{inparaenum}
    \item pode ser definido um inteiro não negativo -- sem sinal. Esse valor
          denota o nível de indentação absoluto para a captura em questão. Em
          outras palavras:
          \begin{inparaenum}
            \item se o valor for 0, os nós capturados terão nenhum deslocamento
                  em relação ao início da linha, independentemente do estilo de
                  indentação definido via \codesnippetinline{indent-style};
            \item se o valor for 1, os nós capturados serão deslocados por uma
                  string idêntica ao estilo de indentação definido;
            \item se o valor for 2, os nós capturados serão deslocados por uma
                  sequência de caracteres equivalente a duas strings
                  subsequentes do estilo de indentação; e assim por diante.
          \end{inparaenum}

          \newsavebox\querystringregex
          \begin{lrbox}{\querystringregex}
            \codesnippetinline{[-0-9a-zA-Z]}[fontsize=\footnotesize]
          \end{lrbox}

          \newsavebox\indentruleabs
          \begin{lrbox}{\indentruleabs}
            \codesnippetinline
              [scheme]
              {(#set! @node indent-rule 0)}
              [fontsize=\footnotesize]
          \end{lrbox}

          \newsavebox\indentruleneg
          \begin{lrbox}{\indentruleneg}
            \codesnippetinline
              [scheme]
              {(#set! @node indent-rule -1)}
              [fontsize=\footnotesize]
          \end{lrbox}

          \newsavebox\indentrulepos
          \begin{lrbox}{\indentrulepos}
            \codesnippetinline
              [scheme]
              {(#set! @node indent-rule "+1")}
              [fontsize=\footnotesize]
          \end{lrbox}

          Além disso,
    \item pode ser especificado um inteiro positivo -- com sinal. Esse número
          configura o nível de indentação adicional para os nós capturados,
          relativo ao deslocamento apresentado pelos pais desses nós. Dessa
          forma:
          \begin{inparaenum}
            \item se o valor for \codesnippetinline{"+1"}%
                  \footnote
                    { É importante ressaltar que, ao fornecer um argumento para
                      um predicado na linguagem de consulta do \treesitter,
                      esse argumento deve ser
                      \begin{inparaenum}[(I)]
                        \item ou uma string,
                        \item ou uma captura.
                      \end{inparaenum}
                      Para especificar uma string, é possível seguir a
                      abordagem tradicional, utilizando as aspas duplas como
                      delimitadores para a sequência de caracteres. No entanto,
                      quando cada caractere da string atende à expressão
                      regular \usebox{\querystringregex}, é possível dispensar
                      os delimitadores. Consequentemente, para configurar uma
                      regra de indentação, é possível especificar uma regra:
                      \begin{inparaenum}[(I)]
                        \item absoluta via \usebox{\indentruleabs},
                        \item relativa negativa usando \usebox{\indentruleneg},
                              e
                        \item relativa positiva com \usebox{\indentrulepos}.
                      \end{inparaenum}}%
                  , os nós capturados
                  serão deslocados mais um \codesnippetinline{indent-style}
                  além do que seus pais apresentam; já
            \item se o valor for \codesnippetinline{"+2"}, o deslocamento
                  adicional será de dois \codesnippetinline{indent-style}; e
                  assim sucessivamente.
          \end{inparaenum}

          Encerrando, dentre os diferentes tipos de valores aceitos pela
          configuração de regra de indentação (\codesnippetinline{indent-rule})
          via o predicado \codesnippetinline{set!},
    \item pode ser passado um inteiro negativo. Atualmente, esse valor é usado
          para calcular o número de caracteres pelo qual os nós capturados
          devem recuar em relação ao deslocamento dos seus pais. Esse cálculo
          é efetuado multiplicando-se o módulo do valor passado pela quantidade
          de caracteres que o estilo de indentação -- definido via
          \codesnippetinline{indent-style} -- contém. Por exemplo, considerando
          que o deslocamento dos nós pais é de 4 caracteres e que o estilo de
          indentação foi definido como \codesnippetinline{"  "} (dois espaços):
          \begin{inparaenum}
            \item se -1 for passado, os nós capturados recuarão 2 caracteres e
                  seu deslocamento será de 2 caracteres;
            \item se o valor for -2, o recuo dos nós capturados será de 4
                  caracteres, e o deslocamento desses nós será de 0 caracteres
                  -- i.e., início da linha --; por fim,
            \item se o número especificado for -3, ocorrerá um erro, pois o
                  recuo calculado de 6 caracteres será maior que o deslocamento
                  dos nós pais, que é de apenas 4 caracteres.
          \end{inparaenum}
  \end{inparaenum}

  Outra prática comum de formatação consiste em alinhar a indentação de um nó
  com o deslocamento de outro nó arbitrário. Para alcançar esse tipo de
  formatação, pode-se fazer uso da configuração
  \codesnippetinline{indent-rule}. No entanto, devido à natureza dessa
  operação, que requer a relação de nós de capturas distintas, o uso do
  predicado \codesnippetinline{set!} não é adequado, uma vez que esse predicado
  permite apenas atribuir uma string a uma captura. Portanto, para estabelecer
  essa relação de deslocamento entre dois nós, o \witchcooking disponibiliza o
  predicado \codesnippetinline{indent-offset!}. Esse predicado aceita duas
  capturas como argumentos, onde as regras de indentação dos nós capturados
  pela primeira captura serão definidas com base nos deslocamentos dos nós
  capturados pela segunda captura.

  Para ilustrar o uso do predicado \codesnippetinline{indent-offset!},
  tome como referência o seguinte trecho de código em linha:
  \codesnippetinline[rust]{fn foo() {bar()}}. Esse código, escrito na linguagem
  de programação Rust, consiste em uma função concisa. A fim de formatar essa
  função de acordo com a variante \textit{1TBS} do estilo de indentação
  \textit{K\&R} \cite{wiki-2023-indentation}, é possível utilizar a consulta
  mostrada no \cref{snippet:scheme:rust:1tbs-fn}. Nessa consulta,
  \begin{inparaenum}
    \item estão presentes 3 capturas:
          \begin{inparaenum}
            \item \codesnippetinline{item}, que captura qualquer elemento do
                  corpo da função;
            \item \codesnippetinline{close}, que captura o delimitador final do
                  corpo da função; e
            \item \codesnippetinline{fn}, que engloba toda a definição da
                  função.
          \end{inparaenum}
          Dentre essas capturas,
    \item \codesnippetinline{item} tem sua regra de indentação especificada
          como um nível de indentação além do deslocamento do nó pai -- i.e., a
          própria função --; e
    \item \codesnippetinline{close} tem sua regra de indentação definida como o
          deslocamento de \codesnippetinline{fn} por meio do uso do predicado
          \codesnippetinline{indent-offset!}. Concluindo, ao final do segundo
          padrão, é utilizado o predicado \codesnippetinline{indent!}, passando
          as respectivas capturas \codesnippetinline{item} e
          \codesnippetinline{close} como argumentos. O resultado da aplicação
          dessa consulta está disponível para verificação no
          \cref{snippet:rust:1tbs-foo}.
  \end{inparaenum}

  \noindent
  \begin{minipage}[t]{\halftextwidthplusfiveempart}
    \begin
      {codesnippet}%
      [scheme]%
      {Consulta para Formatar uma Função de Acordo Com o Estilo \textit{1TBS}}%
      {rust:1tbs-fn}%
      [fontsize=\ABNTEXfontereduzida]
      (#set! indent-style "    ")

      ( (function_item
          body: (block (_) @item "}" @close)) @fn
        (#set! @item indent-rule "+1")
        (#indent-offset! @close @fn)
        (#indent! @item @close))
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{\halftextwidthplusfiveemcounterpart}
    \begin
      {codesnippet}%
      [rust]%
      {Função Indentada de Acordo Com o Estilo \textit{1TBS} em Rust}%
      {1tbs-foo}
      fn foo() {
          bar()
      }
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  %%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Something Is Missing %
  %%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Falta Algo}
  \label{section:missing}

  Ao final do desenvolvimento do \witchcooking, foi conduzida uma série de
  testes para verificar se o código formatado atendia às expectativas, conforme
  o código e as instruções submetidas. Um desses testes envolvia a formatação
  de duas funções aninhadas. O propósito desse teste era averiguar o
  comportamento da formatação em um contexto de aninhamento; ou seja, onde um
  trecho de código sofre o mesmo procedimento de formatação múltiplas vezes,
  mas com base em nós distintos.

  Para realizar esse teste, foram submetidos:
  \begin{inparaenum}
    \item o código-fonte escrito em Rust, que incluía as funções que
          configuravam o aninhamento, ilustrado no
          \cref{snippet:rust:foo-bar-baz}; assim como
    \item as instruções de formatação, escritas na linguagem de consulta do
          \treesitter, apresentadas no \cref{snippet:scheme:rust:1tbs-mod}.
  \end{inparaenum}
  A consulta submetida tinha o propósito de instruir a formatação, de modo que
  o resultado seguisse uma variante do estilo de indentação \textit{1TBS} que
  utiliza 2 espaços em vez dos tradicionais 4 espaços. Assim, o código-fonte
  formatado deveria apresentar a estruturação apresentada no
  \cref{snippet:rust:foo-bar-baz-1tbs}.

  \noindent
  \begin{minipage}[t]{\textwidth}
    \begin
      {codesnippet}%
      [rust]%
      {Funções Aninhadas em Rust}%
      {foo-bar-baz}
      fn foo() {fn bar() {baz()}}
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  \noindent
  \begin{minipage}[t]{\halftextwidthplusfiveempart}
    \begin
      {codesnippet}%
      [scheme]%
      { Consulta para Formatar Funções de Acordo Com uma Variante do Estilo
        \textit{1TBS}}%
      {rust:1tbs-mod}%
      [fontsize=\ABNTEXfontereduzida]
      (#set! indent-style "  ")

      ( (function_item
          body: (block (_) @item "}" @close)) @fn
        (#set! @item indent-rule "+1")
        (#indent-offset! @close @fn)
        (#indent! @item @close))
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{\halftextwidthplusfiveemcounterpart}
    \begin
      {codesnippet}%
      [rust]%
      {Funções Aninhadas Conforme a Variante do Estilo \textit{1TBS} em Rust}%
      {foo-bar-baz-1tbs}
      fn foo() {
        fn bar() {
          baz()
        }
      }
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  No entanto, ao analisar o resultado da execução do \witchcooking, notou-se um
  código que destoa significativamente das expectativas, conforme apresentado
  no \cref{snippet:rust:foo-bar-baz-bad}. Esse código revela dois problemas
  relevantes. Primeiramente, é evidente que
  \begin{inparaenum}
    \item a indentação não está correta. Isso ocorre porque a expressão de
          função \codesnippetinline[rust]{baz()} possui o mesmo nível de
          indentação que a declaração de função
          \codesnippetinline[rust]$fn bar() {$, a qual engloba a expressão.
          Além disso, e de maior gravidade, percebe-se
    \item a ausência de uma chave que caracterize o fechamento do
          corpo da função \codesnippetinline[rust]$fn foo() {$. Ou seja, a
          formatação de um código sintaticamente correto ocasionou um erro de
          sintaxe.
  \end{inparaenum}

  \noindent
  \begin{minipage}[t]{\textwidth}
    \begin
      {codesnippet}%
      [rust]%
      {Funções Aninhadas Mal Formatadas em Rust}%
      {foo-bar-baz-bad}
      fn foo() {
        fn bar() {
        baz()
      }
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  Para entender as causas de ambos os problemas, é necessário seguir uma
  explicação passo a passo dos procedimentos realizados. Começando pela má
  indentação presente na linha 3 do \cref{snippet:rust:foo-bar-baz-bad}, é
  essencial compreender o funcionamento do segundo padrão da consulta
  submetida, apresentado no \cref{snippet:scheme:rust:1tbs-mod}. Esse padrão,
  que lida com declarações de funções em Rust,
  \begin{inparaenum}
    \item impõe um nível adicional de indentação em relação à função para os
          elementos dentro do corpo da própria função. Além disso, ele
    \item alinha a chave de fechamento do corpo da função com o início da
          própria função.
  \end{inparaenum}

  Durante o processo de busca por correspondências do segundo padrão, realizado
  pelo \treesitter, a primeira função a coincidir com o padrão é função
  \codesnippetinline[rust]{fn bar() {baz()}}. Como posteriormente, no algoritmo
  de formatação do \witchcooking, a aplicação dos predicados ocorre
  sequencialmente conforme a ordem das correspondências, essa função é a
  primeira a ser formatada. Após a aplicação do primeiro procedimento de
  formatação, o código em formatação apresenta a configuração demonstrada no
  \cref{snippet:rust:foo-bar-baz-step-1}.

  \noindent
  \begin{minipage}[t]{\textwidth}
    \begin
      {codesnippet}%
      [rust]%
      {Primeiro Passo da Formatação das Funções Aninhadas em Rust}%
      {foo-bar-baz-step-1}
      fn foo() {fn bar() {
        baz()
                }}
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  Nesse código, destaca-se o deslocamento da expressão de função
  \codesnippetinline[rust]{baz()}, cuja regra de indentação foi especificada
  via \codesnippetinline[scheme]{(#set! @item indent-rule "+1")}, conforme o
  \cref{snippet:scheme:rust:1tbs-mod}. Com base na explicação da
  \cref{section:instructing}, essa configuração define que o deslocamento da
  expressão de função, capturada via \codesnippetinline{@item}, será calculado
  como a combinação:
  \begin{inparaenum}
    \item do estilo de indentação vigente com
    \item o deslocamento do primeiro caractere não espaço encontrado na linha
          onde começa o nó pai da expressão.
  \end{inparaenum}
  Nesse contexto, o nó pai é o corpo da função \codesnippetinline{bar}, que
  começa na linha 1. Dado que
  \begin{inparaenum}
    \item o primeiro caractere não espaço nessa linha está no início da própria
          linha e
    \item o estilo de indentação vigente é \codesnippetinline{"  "},
  \end{inparaenum}
  a indentação aplicada à expressão de função \codesnippetinline[rust]{baz()}
  configura uma formatação peculiar, como vista no
  \cref{snippet:rust:foo-bar-baz-step-1}.

  Prosseguindo com a compreensão dos procedimentos sucedidos, a segunda função
  a corresponder ao segundo padrão da consulta submetida é a função
  \codesnippetinline{foo}, que engloba todo o código. Similarmente ao ocorrido
  com a função \codesnippetinline{bar}, a aplicação do padrão nessa função
  supostamente resultaria na indentação:
  \begin{inparaenum}
    \item da função \codesnippetinline{bar} e
    \item da chave que fecha o corpo da função \codesnippetinline{foo}.
  \end{inparaenum}
  No entanto, após a execução do segundo procedimento de formatação, o código
  problemático em estudo, apresentado anteriormente no
  \cref{snippet:rust:foo-bar-baz-bad}, é gerado.

  Ao comparar o código resultante do segundo e último procedimento de
  formatação com o código esperado, ilustrado no
  \cref{snippet:rust:foo-bar-baz-1tbs}, observa-se que as duas primeiras linhas
  são idênticas, ou seja, seguem a variante do estilo \textit{1TBS}. No
  entanto, na terceira linha do \cref{snippet:rust:foo-bar-baz-bad}, a
  indentação da expressão da função \codesnippetinline[rust]{baz()} é
  claramente inadequada, pois coincide com a indentação da declaração da função
  que a envolve. Esse problema decorre do cálculo de indentação executado pelo
  predicado \codesnippetinline{indent!}.

  Conforme já explicado, na implementação atual, quando é estabelecida uma
  regra de indentação relativa positiva para um nó, o cálculo é baseado:
  \begin{inparaenum}
    \item no deslocamento do primeiro caractere não espaço encontrado na linha
          do pai desse nó, e não
    \item \label{item:parent-offset} no deslocamento do próprio nó pai.
  \end{inparaenum}
  No entanto, o cálculo com base no \cref{item:parent-offset} poderia ser mais
  apropriado, especialmente em circunstâncias de aninhamento. Por exemplo, se
  a indentação fosse calculada conforme o deslocamento do nó pai, ao realizar
  o primeiro procedimento de formatação no \cref{snippet:rust:foo-bar-baz-bad},
  utilizando a mesma consulta do \cref{snippet:scheme:rust:1tbs-mod} como base,
  o resultado seria conforme ilustrado no
  \cref{snippet:rust:foo-bar-baz-step-1-hipo}.

  \noindent
  \begin{minipage}[t]{\halfpart}
    \begin
      {codesnippet}%
      [rust]%
      {Primeiro Passo Hipotético da Formatação das Funções Aninhadas em Rust}%
      {foo-bar-baz-step-1-hipo}
      fn foo() {fn bar() {
                  baz()
                }}
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{\halfpart}
    \begin
      {codesnippet}%
      [rust]%
      {Segundo Passo Hipotético da Formatação das Funções Aninhadas em Rust}%
      {foo-bar-baz-step-2-hipo}
      fn foo() {
        fn bar() {
          baz()
        }
      }
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  Outro ponto passível de aprimoramento é a própria aplicação da indentação,
  que é também realizada pelo predicado \codesnippetinline{indent!}.
  Atualmente, esse predicado executa a indentação com base somente na linha
  inicial do nó em procedimento. Como resultado, ao aplicar a indentação à
  função \codesnippetinline{bar} no \cref{snippet:rust:foo-bar-baz-step-1}, o
  conteúdo dessa função -- a expressão de função
  \codesnippetinline[rust]{baz()} -- que está em outra linha, permanece
  inalterado. Contudo, seria mais coerente se a indentação ocorresse em bloco,
  ou seja, o deslocamento seria aplicado para cada linha abrangida pelo nó em
  questão. Com essa melhoria, ao aplicar a consulta do
  \cref{snippet:scheme:rust:1tbs-mod} ao
  \cref{snippet:rust:foo-bar-baz-step-1-hipo}, o resultado seria o conteúdo
  ilustrado no \cref{snippet:rust:foo-bar-baz-step-2-hipo}. Uma vez que esse
  código segue a variante do estilo \textit{1TBS}, o teste teria seu objeto
  cumprido.

  No entanto, ao retomar a análise do código problemático mostrado no
  \cref{snippet:rust:foo-bar-baz-bad}, o comparando com código hipotético
  resultante das melhorias discutidas, observa-se que o código hipotético não
  apresentou um erro de sintaxe decorrente da falta da chave que fecha o corpo
  da função \codesnippetinline{foo}. Isso ocorreu porque, na exemplificação
  dessas possíveis melhorias, não foi considerado o problema que origina a
  omissão da chave em questão. Por sua vez, essa desconsideração ocorreu porque
  esse problema não deriva diretamente do \witchcooking, mas sim de uma
  característica da biblioteca \treesitter: ao sincronizar um nó, as edições
  ocorridas tangentes à sua extensão não são contabilizadas.

  Para compreender a complexidade envolvida nesse problema, é essencial
  entender minimamente o funcionamento do processo de formatação; mais
  especificamente, como o processo de edição do código em formatação opera.
  Conforme mencionado na \cref{section:fmt-algorithm}, o algoritmo de
  formatação é composto, entre outros componentes, por uma estrutura editora.
  Essa estrutura retém o código-fonte em formatação e registra as edições (ou
  modificações) realizadas pelos predicados.

  Para realizar as edições, um predicado sempre se baseia em ao menos um nó.
  Dentre as informações que um nó possui, está a extensão de caracteres que o
  configura no código-fonte. Essa extensão compreende um início e um fim
  representados em ambos os níveis:
  \begin{inparaenum}
    \item de bytes, especificando o deslocamento dentre os bytes do
          código-fonte; bem como
    \item de pontos, onde cada ponto refere-se a uma linha e uma coluna
          específica.
  \end{inparaenum}
  Originalmente, os nós capturados nos padrões mantém as extensões conforme
  presentes no código-fonte submetido. Portanto, ao manipulá-los, os
  predicados devem sincronizar os nós para que suas extensões estejam
  consoantes ao código vigente em processo de formatação.

  Como demonstrado no \cref{appendice:ts-sync-proof}, ao sincronizar um nó, o
  \treesitter não contabiliza edições tangentes à extensão desse nó.
  Consequentemente, especialmente em cenários que apresentam estruturas
  aninhadas, durante o processo de formatação, ao sincronizar um nó, há uma
  probabilidade considerável de que ele apresente uma extensão corrompida. Não
  surpreendentemente, essa é a razão por trás da omissão da chave, conforme
  demonstrada no \cref{snippet:rust:foo-bar-baz-bad}. Essa chave -- que foi
  capturada via \codesnippetinline{@close} -- tem sua regra de indentação
  definida como o deslocamento da função \codesnippetinline{foo}, como mostra o
  seguinte fragmento em linha do \cref{snippet:scheme:rust:1tbs-mod}:
  \codesnippetinline[scheme]{(#indent-offset! @close @fn)}. Para indentá-la,
  mais especificamente, para aplicar os caracteres que configuram sua
  indentação, o predicado \codesnippetinline{indent!} busca um nó irmão que
  preceda a chave. Esse nó, por sua vez, é a função \codesnippetinline{bar}, a
  qual já fora modificada nos procedimentos anteriores. Como resultado, o
  predicado considera a extensão corrompida dessa função e, consequentemente,
  aplica a indentação que sobrescreve a chave que fecha o corpo da função
  \codesnippetinline{bar}.

  %%%%%%%%%%%%%
  %%% Results %
  %%%%%%%%%%%%%

  \section{Resultados}

  Conforme demonstrado ao longo desse capítulo, o algoritmo desenvolvido, que é
  fundamentado no \treesitter, permite a formatação -- multilíngue e
  personalizada -- de código-fonte via as implementações que estendem a
  biblioteca. Mais especificamente, em adição à base fornecida pelo
  \treesitter, a formatação é proporcionada pelas:
  \begin{inparaenum}
    \item configurações, sendo elas
          \begin{inparaenum}
            \item \codesnippetinline{indent-rule} e
            \item \codesnippetinline{indent-style};
          \end{inparaenum}
          em conjunto com
    \item os predicados, sendo eles
          \begin{inparaenum}
            \item \codesnippetinline{space!},
            \item \codesnippetinline{indent!}, e
            \item \codesnippetinline{indent-offset!}.
          \end{inparaenum}
  \end{inparaenum}

  Como explicado e demonstrado na \cref{section:instructing}, é possível
  desempenhar procedimentos básicos de formatação através do \witchcooking. Nos
  exemplos utilizados, é perceptível que o código-fonte submetido para
  formatação já possui uma organização razoável. Ou seja, a ferramenta foi
  utilizada para realizar operações pontuais de formatação. Contudo, na
  \cref{section:missing}, a partir de um cenário mais complexo de formatação,
  foi apresentado um mau funcionamento na sincronização das extensões dos nós.
  Conforme reportado, essa falha, que deriva de uma característica peculiar do
  \treesitter, compromete o uso da ferramenta para efetuar procedimentos de
  formatação mais robustos. Portanto, ao considerar cenários mais realistas,
  nos quais não é possível presumir algo sobre a estruturação inicial do
  código, não é prudente pressupor que consultas mais complexas sejam capazes
  de abranger esses cenários sem ocasionar erros de sintaxe.

  Um dos principais elementos no \textit{prettyprinting} é o
  \textit{\gloss[short]{cpl}}, que se refere à quantidade máxima de caracteres
  permitida em uma única linha. No contexto da formatação de código-fonte,
  embora esse elemento tenha perdido parte de sua relevância atualmente%
  \footnote
    { Embora o \textit{CPL} tenha tido origem nas limitações técnicas dos
      equipamentos, as várias mudanças, incluindo melhorias significativas, no
      ambiente de desenvolvimento e nas tecnologias utilizadas transformaram o
      conceito de \textit{CPL} em algo de menor relevância. Dentre os fatores
      que corroboraram para isso, destacam-se:
      \begin{inparaenum}
        \item a disponibilidade de monitores de alta resolução,
        \item editores de texto avançados,
        \item recursos de formatação automática, e
        \item práticas de codificação modular.
      \end{inparaenum}}%
  , muitos guias de estilo para diferentes linguagens de programação ainda
  estipulam um valor para o \textit{CPL} \cite{wiki-2023-characters}.
  Consequentemente, o código formatado por diversos \textit{prettyprinters}
  continua a ser diretamente influenciado por esse parâmetro. Apesar da
  importância que o \textit{CPL} normalmente desempenha na formatação, o
  \witchcooking atualmente não fornece algum mecanismo de formatação conforme
  esse aspecto. Mais precisamente, a ferramenta carece de mecanismos que
  proporcionem formatação condicionada, em geral.

  %%%%%%%%%%%%%%%
  %% Conclusion %
  %%%%%%%%%%%%%%%

  \chapter{Conclusão}

  %%%%%%%%%%%%%%%%%%%%%%%%%
  % Post Textual Elements %
  %%%%%%%%%%%%%%%%%%%%%%%%%

  \postextual
  \printbibliography
  \printgloss{glossary}

  %%%%%%%%%%%%%%%
  %% Appendices %
  %%%%%%%%%%%%%%%

  \begin{apendicesenv}
    \partapendices

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Tree-Sitter's Node Syncing %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \chapter{Sincronizando Nós do \treesitter}
    \label{appendice:ts-sync-proof}

    Na \cref{section:missing}, foi mencionado que, ao sincronizar um nó, a
    biblioteca \treesitter não contabiliza as edições ocorridas que tangem a
    extensão desse nó. Este apêndice tem como objetivo demonstrar esse
    comportamento de forma didática. Para reproduzí-lo, é necessário:
    \begin{inparaenum}
      \item Rust \cite{rust-2023-rust}, a linguagem de programação;
      \item \textit{Cargo} \cite{rust-2023-cargo}, o gerenciador de pacotes
            dessa linguagem; além das bibliotecas
      \item \textit{tree-sitter} e
      \item \textit{tree-sitter-rust}.
    \end{inparaenum}

    Primeiramente, o comando \codesnippetinline[sh]{cargo new ts-node-edit}
    é executado para criar um novo pacote executável \textit{Cargo}, que será
    utilizado para a demonstração. Em seguida, o comando
    \codesnippetinline[sh]{cd ts-node-edit} é executado para navegar até o
    diretório recém-criado. Nesse diretório, para adicionar as dependências --
    i.e., as bibliotecas -- necessárias, é executado o seguinte comando:
    \codesnippetinline[sh]{cargo add tree-sitter{,-rust}}. Dessa forma, a
    configuração inicial é concluída.

    Para escrever o código, é necessário editar o arquivo localizado no
    seguinte caminho: \codesnippetinline{src/main.rs}. A seguir, serão
    mostrados e explicados os trechos que compõe o código da demonstração. Essa
    abordagem fragmentada foi adotada por dois motivos:
    \begin{inparaenum}
      \item explicar os procedimentos na ordem de execução, e
      \item evitar problemas de formatação neste documento.
    \end{inparaenum}

    Conforme ilustrado no \cref{snippet:rust:ts-node-edit-demo-part-1}, na
    primeira linha,
    \begin{inparaenum}
      \item são importados alguns itens da biblioteca \treesitter que são
            utilizados nessa demonstração. Já na linha 3,
      \item inicia-se a função principal, que engloba todos os procedimentos.
            Em seguida,
      \item é definido a string do código-fonte usado como referência na
            demonstração: \codesnippetinline[rust]{fn foo() {}}. Além disso,
            da linha 5 a 7,
      \item são realizados procedimentos para gerar a árvore de sintaxe a
            partir da análise do código-fonte definido anteriormente.
    \end{inparaenum}

    Continuando, no \cref{snippet:rust:ts-node-edit-demo-part-2}, observa-se
    que na linha 8,
    \begin{inparaenum}
      \item é obtido um nó que supostamente remete à função
            \codesnippetinline{foo}. Logo na linha seguinte,
      \item essa suposição é validada por uma asserção. Já nas linhas
            subsequentes,
      \item são realizados procedimentos similares, porém buscando o nó que
            representa o nome da função.
    \end{inparaenum}
    Em seguida, nos
    \cref
      {%
        snippet:rust:ts-node-edit-demo-part-3,%
        snippet:rust:ts-node-edit-demo-part-4}%
    , são executadas duas asserções semelhantes. Essas asserções verificam os
    valores originais das extensões --- tanto em bytes quanto em pontos --- dos
    nós:
    \begin{inparaenum}
      \item da função \codesnippetinline{foo} e
      \item do seu nome.
    \end{inparaenum}

    \noindent
    \begin{minipage}[t]{\textwidth}
      \begin
        {codesnippet}%
        [rust]%
        {Primeiro Trecho da Demonstração da Sincronização de Nós em Rust}%
        {ts-node-edit-demo-part-1}
        use tree_sitter::{InputEdit, Parser, Point, Range};

        fn main() {
          let src = "fn foo() {}";
          let mut parser = Parser::new();
          parser.set_language(tree_sitter_rust::language()).unwrap();
          let tree = parser.parse(src, None).unwrap();
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        {\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
    \end{minipage}

    \noindent
    \begin{minipage}[t]{\textwidth}
      \begin
        {codesnippet}*%
        [rust]%
        {Segundo Trecho da Demonstração da Sincronização de Nós em Rust}%
        {ts-node-edit-demo-part-2}%
        [%
          autogobble=false,
          firstnumber=last,
          fontsize=\ABNTEXfontereduzida,
          gobble=8,
          lastline=4]
          let mut fn_item = tree.root_node().child(0).unwrap();
          assert_eq!("function_item", fn_item.kind());
          let mut fn_name = fn_item.child_by_field_name("name").unwrap();
          assert_eq!("identifier", fn_name.kind());
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        {\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
    \end{minipage}

    \noindent
    \begin{minipage}[t]{\textwidth}
      \begin
        {codesnippet}*%
        [rust]%
        {Terceiro Trecho da Demonstração da Sincronização de Nós em Rust}%
        {ts-node-edit-demo-part-3}%
        [autogobble=false,firstnumber=last,gobble=8,lastline=9]
          assert_eq!(
            Range {
              start_byte: 0,
              end_byte: 11,
              start_point: Point { row: 0, column: 0 },
              end_point: Point { row: 0, column: 11 },
            },
            fn_item.range(),
          );
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        {\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
    \end{minipage}

    \noindent
    \begin{minipage}[t]{\textwidth}
      \begin
        {codesnippet}*%
        [rust]%
        {Quarto Trecho da Demonstração da Sincronização de Nós em Rust}%
        {ts-node-edit-demo-part-4}%
        [autogobble=false,firstnumber=last,gobble=8,lastline=9]
          assert_eq!(
            Range {
              start_byte: 3,
              end_byte: 6,
              start_point: Point { row: 0, column: 3 },
              end_point: Point { row: 0, column: 6 },
            },
            fn_name.range(),
          );
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        {\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
    \end{minipage}
  \end{apendicesenv}
\end{document}