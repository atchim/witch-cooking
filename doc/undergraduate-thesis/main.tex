%%%%%%%%%%%%
% Preamble %
%%%%%%%%%%%%

\documentclass
  [11pt,a4paper,english,brazil,openright,sumario=tradicional,twoside]
  {abntex2}

%%%%%%%%%%%%%
%% Packages %
%%%%%%%%%%%%%

%%%%%%%%%%%%%%
%%% Encoding %
%%%%%%%%%%%%%%

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

%%%%%%%%%%%%%%%%%%%%%
%%% ABNT Compliance %
%%%%%%%%%%%%%%%%%%%%%

\usepackage{indentfirst}
\usepackage{microtype}

%%%%%%%%%%%%%%
%%% Glossary %
%%%%%%%%%%%%%%

\let\glossitem\undefined
\usepackage[portuguese]{gloss}

%%%%%%%%%%%%%%%%%%%
%%% Miscellaneous %
%%%%%%%%%%%%%%%%%%%

\usepackage{amsmath}
\usepackage[backend=biber,indent,style=abnt]{biblatex}
\usepackage{calc}
\usepackage{caption}
\usepackage[brazilian]{cleveref}
\usepackage{color}
\usepackage[listings,minted,skins,xparse]{tcolorbox}
\usepackage{csquotes}
\usepackage{graphicx}
\usepackage{minted}
\usepackage{palatino}
\usepackage{paralist}
\usepackage{tikz}

%%%%%%%%%%%%%%%%%%
%% Configuration %
%%%%%%%%%%%%%%%%%%

\input{aliases.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% ABNT's NBR 14724 Metrics Compliance %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\setlength{\parindent}{1.3cm}
\setlength{\parskip}{0.2cm}

%%%%%%%%%%%%%
%%% abntex2 %
%%%%%%%%%%%%%

\renewcommand{\ABNTEXchapterfont}{\fontseries{b}}
\renewcommand{\apendicename}{Apêndice}
\renewcommand{\folhaderostoname}{Folha de Rosto}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Cover & Title Page Info %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\titulo{\witchcooking: \witchcookingsubtitle}
\autor{Átila Gama Silva}
\local{Irecê}
\data{\the\year}
\orientador{Rafael Xavier}
\instituicao{\ifba}
\tipotrabalho{Trabalho de Conclusão de Curso}
\preambulo
  {%
    Trabalho de Conclusão de Curso apresentado ao Curso Técnico em Análise e
    Desenvolvimento de Sistemas do \ifba, como requisito parcial para obtenção
    do diploma de Técnico em Análise e Desenvolvimento de Sistemas, mediante a
    orientação do professor \imprimirorientador.}

%%%%%%%%%%%%%
%%%% Dashes %
%%%%%%%%%%%%%

\renewcommand{\ABNTEXcaptiondelim}{~\textemdash~}
\captiondelim{\ABNTEXcaptiondelim}
\cftinsertcode{A}{\renewcommand{\cftchapteraftersnum}{\hfill\textemdash\hfill}}

%%%%%%%%%%%%%%%%%%%
%%%% IFBA's Cover %
%%%%%%%%%%%%%%%%%%%

\renewcommand
  {\imprimircapa}
  {%
    \begin{capa}
      \ABNTEXchapterfont
      \ABNTEXsectionfontsize
      \center
      \includegraphics[width=\textwidth]{ifba-irece-logo.png}
      \par\vfill\imprimirautor
      \par\vfill{\ABNTEXchapterfontsize\imprimirtitulo}
      \vfill\vfill
      \par\imprimirlocal\break\imprimirdata
    \end{capa}}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%% IFBA's Title Page %
%%%%%%%%%%%%%%%%%%%%%%%%

\makeatletter
\renewcommand
  {\folhaderostocontent}
  {%
    \begin{center}
      \ABNTEXchapterfont
      \ABNTEXsectionfontsize
      \imprimirautor
      \par\vfill\vfill{\ABNTEXchapterfontsize\imprimirtitulo}
      \vfill
      {%
        \normalsize
        \mdseries
        \hspace{.45\textwidth}
        \begin{minipage}{.5\textwidth}
          \SingleSpacing
          \imprimirpreambulo
        \end{minipage}}
      \vfill\vfill
      \imprimirlocal\break\imprimirdata
    \end{center}}
\makeatother

%%%%%%%%%
%%% TOC %
%%%%%%%%%

%%%%%%%%%%%%%%%
%%%% Settings %
%%%%%%%%%%%%%%%

\setlength{\cftlastnumwidth}{\cftsectionnumwidth}

\cftsetindents{chapter}{0em}{\cftlastnumwidth}
\cftsetindents{part}{0em}{\cftlastnumwidth}
\cftsetindents{section}{0em}{\cftlastnumwidth}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Command Redefinition %
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand
  {\tocinnonumchapter}
  {%
    \addtocontents{toc}{\cftsetindents{chapter}{\cftlastnumwidth}{2em}}
    \cftinserthook{toc}{A}}

\renewcommand
  {\tocpartapendices}
  {%
    \addtocontents{toc}{\cftsetindents{part}{\cftlastnumwidth}{2em}}
    \cftinserthook{toc}{A}}

\renewcommand
  {\tocprintchapter}
  {\addtocontents{toc}{\cftsetindents{chapter}{0em}{\cftlastnumwidth}}}

\renewcommand
  {\tocprintchapternonum}
  {\addtocontents{toc}{\cftsetindents{chapter}{\cftlastnumwidth}{2em}}}

\renewcommand{\cftchapterfont}{\bfseries}
\renewcommand{\cftchapterpagefont}{\cftchapterfont}
\renewcommand{\cftpartfont}{\bfseries}
\renewcommand{\cftpartpagefont}{\cftpartfont}
\renewcommand{\cftsectionfont}{\cftchapterfont}
\renewcommand{\cftsectionpagefont}{\cftsectionfont}

\renewcommand{\backmatter}{}
\renewcommand{\postextual}{}

\makeatletter
\renewcommand{\partapendices}{\tocpartapendices\appendixpage}
\makeatother

%%%%%%%%%%%%%%%%%%
%%% Bibliography %
%%%%%%%%%%%%%%%%%%

\addbibresource{references.bib}

%%%%%%%%%%%%%%
%%% cleveref %
%%%%%%%%%%%%%%

\crefname{listing}{trecho de código}{trechos de código}

%%%%%%%%%%%%%%%%%%%
%%% Code Snippets %
%%%%%%%%%%%%%%%%%%%

\renewcommand{\theFancyVerbLine}{\ttfamily\arabic{FancyVerbLine}}

\definecolor{codehighlight}{RGB}{240,240,170}
\newcommand{\hi}[1]{\colorbox{codehighlight}{#1}}
\setminted{highlightcolor={codehighlight},spacecolor=gray!50}

\NewTotalTCBox
  {\codesnippetinline}
  {O{text}vO{}}
  { bottom=0pt,
    enhanced,
    frame hidden,
    left=0pt,
    on line,
    right=0pt,
    sharp corners,
    top=0pt}
  {\mintinline[#3]{#1}{#2}}%

\NewTCBListing
  [auto counter,list inside=codesnippets]
  {codesnippet}
  {sO{text}mm!O{}!O{}}
  { enhanced,
    center title,
    coltitle=black,
    fonttitle=\ABNTEXfontereduzida,
    frame hidden,
    label={snippet:#2:#4},
    label type=listing,
    list entry={Trecho de Código \thetcbcounter{} --- #3},
    listing engine=minted,
    listing only,
    minted language=#2,
    minted options=
      { autogobble,
        breakanywhere,
        breakanywheresymbolpre={},
        breakautoindent=false,
        breaklines,
        breaksymbol={},
        linenos,
        xleftmargin=\IfBooleanTF{#1}{1.5}{1}em,
        #5},
    overlay=
      {%
        \begin{tcbclipinterior}
          \fill[gray!25]
          (frame.south west)
          rectangle
          ([xshift=\IfBooleanTF{#1}{2.5}{2}em]frame.north west);
        \end{tcbclipinterior}},
    sharp corners,
    title={Trecho de Código \thetcbcounter{} --- #3},
    #6}

%%%%%%%%%%%%%
%%% Figures %
%%%%%%%%%%%%%

\NewTotalTCBox
  [auto counter,list inside=figureswrapper]
  {\figurewrapper}
  {mmO{}m}
  { enhanced,
    center title,
    coltitle=black,
    fonttitle=\ABNTEXfontereduzida,
    frame hidden,
    label={figure:#2},
    label type=figure,
    list entry={Figura \thetcbcounter{} --- #1},
    sharp corners,
    title={Figura \thetcbcounter{} --- #1},
    #3}
  {#4}

%%%%%%%%%%%
%%% Float %
%%%%%%%%%%%

\makeatletter
\setlength{\@fptop}{5pt}
\makeatother

%%%%%%%%%%%%%%
%%% Glossary %
%%%%%%%%%%%%%%

\setglosslabel{\bfseries#2\ifglossshort{ (#3)}{}}
\renewenvironment
  {thegloss}
  {%
    \chapter*{\glossname}
    \markboth{\glossname}{\glossname}
    \addcontentsline{toc}{chapter}{\glossname}}
  {\stopglosslist}
\makegloss

%%%%%%%%%%%%%%
%%% Paralist %
%%%%%%%%%%%%%%

\setdefaultenum{(I)}{(A)}{}{}

%%%%%%%%%
%%% PDF %
%%%%%%%%%

\definecolor{blue}{RGB}{41,5,195}
\makeatletter
\hypersetup
  { pdftitle={\@title},
    pdfauthor={\@author},
    pdfsubject={\witchcooking: \witchcookingsubtitle},
    pdfcreator={\LaTeX with \abnTeX},
    pdfkeywords=
      {formatação de código}
      {\textit{prettyprint}}
      {formatação multilíngue}
      {formatação personalizada}
      {\treesitter},
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    filecolor=magenta,
    urlcolor=blue,
    bookmarksdepth=4}
\makeatother

%%%%%%%%%%
%%% TikZ %
%%%%%%%%%%

\usetikzlibrary{calc,decorations.pathmorphing,positioning}

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\begin{document}
  \selectlanguage{brazil}
  \frenchspacing

  %%%%%%%%%%%
  % Lengths %
  %%%%%%%%%%%

  %%%%%%%%%%%%%%
  %% Half Part %
  %%%%%%%%%%%%%%

  \newlength{\halfpart}
  \setlength{\halfpart}{.5\textwidth - .5em}

  %%%%%%%%%%%%%%%%%%%%%
  %% Text Width Parts %
  %%%%%%%%%%%%%%%%%%%%%

  \newlength{\halftextwidthpart}
  \setlength{\halftextwidthpart}{.5\textwidth}
  \newlength{\halftextwidthcounterpart}
  \setlength{\halftextwidthcounterpart}{.5\textwidth - 1em}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %% Text Width Plus Two em Parts %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \newlength{\halftextwidthplustwoempart}
  \setlength{\halftextwidthplustwoempart}{.5\textwidth + 2em}
  \newlength{\halftextwidthplustwoemcounterpart}
  \setlength{\halftextwidthplustwoemcounterpart}{.5\textwidth - 3em}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %% Text Width Plus Five em Parts %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \newlength{\halftextwidthplusfiveempart}
  \setlength{\halftextwidthplusfiveempart}{.5\textwidth + 5em}
  \newlength{\halftextwidthplusfiveemcounterpart}
  \setlength{\halftextwidthplusfiveemcounterpart}{.5\textwidth - 6em}

  %%%%%%%%%%%%%%
  % Pretextual %
  %%%%%%%%%%%%%%

  \imprimircapa
  \imprimirfolhaderosto

  %%%%%%%%%%%%%
  % Abstracts %
  %%%%%%%%%%%%%

  \setlength{\absparsep}{18pt}

  %%%%%%%%%%%%%%%
  %% Portuguese %
  %%%%%%%%%%%%%%%

  \begin{resumo}
    A formatação de código é fundamental no desenvolvimento de software,
    permitindo estabelecer aspectos desejados como a padronização e
    legibilidade do código, que impactam positivamente o ciclo de vida do
    software. Em ambientes de desenvolvimento modernos, é comum o uso de
    ferramentas para automatizar a formatação de código. No entanto, essas
    ferramentas geralmente apresentam limitações no número de linguagens
    suportadas, nas opções de configuração, e na personalização da formatação.
    Visando superar ou reduzir as limitações frequentemente encontradas nas
    ferramentas convencionais de formatação, neste trabalho é apresentado o
    \witchcooking, um software prototípico de linha de comando, fundamentado no
    sistema \treesitter, que tem como objetivos:
    \begin{inparaenum}
      \item abranger uma gama de linguagens de programação, além de
      \item proporcionar a formatação personalizada via a linguagem de consulta
            do \treesitter.
    \end{inparaenum}
    O software desenvolvido tem potencial para suportar qualquer linguagem que
    tenha uma gramática compatível com a versão do \treesitter utilizada pelo
    \witchcooking. Além disso, o software proporciona a formatação
    personalizada por meio de diretrizes especificadas no arquivo submetido,
    escrito na linguagem de consulta do \treesitter. No entanto, um erro na
    sincronização de nós da sintaxe --- derivado do desconhecimento de uma
    peculiaridade do sistema \treesitter{} --- limita o uso do \witchcooking:
    \begin{inparaenum}
      \item para formatar códigos mais robustos ou
      \item para aplicar diretrizes mais complexas,
    \end{inparaenum}
    uma vez que provavelmente ocasionará erros de sintaxe.

    \noindent
    \textbf{Palavras-chave}:
    formatação de código;
    \textit{prettyprint};
    formatação multilíngue;
    formatação personalizada;
    \treesitter.
  \end{resumo}

  %%%%%%%%%%%%
  %% English %
  %%%%%%%%%%%%

  \begin{resumo}[Abstract]
    \begin{otherlanguage*}{english}
      Code formatting is crucial in software development, allowing for the
      establishment of desired aspects such as code standardization and
      readability, which have a positive impact on the software's life cycle.
      In modern development environments, it's common to use tools to automate
      code formatting. However, these tools often come with limitations in
      terms of supported languages, configuration options, and custom
      formatting. To overcome or reduce the limitations frequently encountered
      in conventional formatting tools, this work introduces \witchcooking, a
      command-line prototypical software built on the \treesitter system. It
      aims to:
      \begin{inparaenum}
        \item encompass a range of programming languages and
        \item provide custom formatting through the \treesitter's query
              language.
      \end{inparaenum}
      The software developed has the potential to support any language with a
      grammar compatible with the version of \treesitter used by \witchcooking.
      Additionally, it offers customized formatting based on guidelines
      specified in the submitted file, written in the \treesitter's query
      language. However, an error in synchronizing syntax nodes --- resulting
      from an unawareness of a peculiarity of the \treesitter system --- limits
      the use of \witchcooking:
      \begin{inparaenum}
        \item for formatting more intricate codes or
        \item for applying more complex guidelines,
      \end{inparaenum}
      as it may likely lead to syntax errors.

      \noindent
      \textbf{Keywords}:
      code formatting;
      \textit{prettyprint};
      multilingual formatting;
      custom formatting;
      \treesitter.
    \end{otherlanguage*}
  \end{resumo}

  %%%%%%%%%%%%%%%%%%%
  % List of Figures %
  %%%%%%%%%%%%%%%%%%%

  \newcommand{\figureswrappername}{Lista de Ilustrações}
  \begin{KeepFromToc}
    \pdfbookmark[0]{\figureswrappername}{figureswrapper}
    \tcblistof[\chapter*]{figureswrapper}{\figureswrappername}
  \end{KeepFromToc}
  \cleardoublepage

  %%%%%%%%%%%%%%%%%%%%%%%%%
  % List of Code Snippets %
  %%%%%%%%%%%%%%%%%%%%%%%%%

  \newcommand{\codesnippetsname}{Lista de Trechos de Código}
  \begin{KeepFromToc}
    \pdfbookmark[0]{\codesnippetsname}{codesnippets}
    \tcblistof[\chapter*]{codesnippets}{\codesnippetsname}
  \end{KeepFromToc}
  \cleardoublepage

  %%%%%%%%%%%%%%%%%%%%%
  % Table of Contents %
  %%%%%%%%%%%%%%%%%%%%%

  \pdfbookmark[0]{\contentsname}{toc}
  \tableofcontents*
  \cleardoublepage

  %%%%%%%%%%%%%%%%%%%%
  % Textual Elements %
  %%%%%%%%%%%%%%%%%%%%

  \textual

  %%%%%%%%%%%%%%%%%
  %% Introduction %
  %%%%%%%%%%%%%%%%%

  \chapter{Introdução}

  A flexibilidade presente na sintaxe de linguagens de programação permite que
  diferentes arranjos de um mesmo código compartilhem um valor sintático
  equivalente. Essa característica possibilita a formatação do código de acordo
  com aspectos desejados, como a legibilidade, que é fundamental no ciclo de
  vida do software
  \cites[546]{buse-2009-learning}[1]{oliveira-2020-evaluating}.
  Consequentemente, a formatação é frequentemente utilizada para estabelecer um
  nível satisfatório de legibilidade em bases de código.

  Para evitar os problemas inerentes à formatação manual, é comum recorrer a
  softwares que automatizam deterministicamente esse processo, garantindo que o
  código seja padronizado e consistente. No entanto, essas ferramentas são
  normalmente restritas a uma linguagem específica ou a uma família de
  linguagens de programação. Além disso, essas ferramentas costumam oferecer
  uma quantidade limitada de configurações de estilização, dificultando a
  personalização pelo usuário. Isso é especialmente agravado em formatadores
  opinativos, onde um estilo é rigorosamente imposto.

  Com o intuito de superar ou reduzir as limitações previamente mencionadas,
  frequentemente presentes nas ferramentas convencionais de formatação, o
  objetivo geral deste trabalho é desenvolver um software prototípico para a
  formatação de código-fonte. Nomeado de \witchcooking \cite{silva-2023-witch},
  o software foi concebido com base no \treesitter
  \cite{tree-sitter-2023-tree}: um sistema de análise sintática de código
  aberto. Mediante esse sistema, o \witchcooking tem como objetivos:
  \begin{inparaenum}
    \item abranger uma gama de linguagens de programação, e
    \item proporcionar a formatação personalizada via a linguagem de consulta
          do \treesitter.
  \end{inparaenum}

  Para alcançar o objetivo geral proposto, este trabalho tem como objetivos
  específicos:
  \begin{inparaenum}
    \item desenvolver um algoritmo de formatação fundamentado no \treesitter;
    \item definir configurações de estilização para o predicado
          \codesnippetinline{set!}, nativo da linguagem de consulta do
          \treesitter; e
    \item estender os predicados embutidos da linguagem de consulta,
          proporcionando predicados basais para a formatação.
  \end{inparaenum}

  A partir do seu desenvolvimento, é esperado:
  \begin{inparaenum}
    \item que o \witchcooking tenha potencial para abranger qualquer linguagem
          que tenha uma gramática gerada pelo \treesitter, e
    \item que os predicados desenvolvidos possibilitem a realização de
          procedimentos básicos de formatação.
  \end{inparaenum}

  Devido à natureza experimental deste trabalho, o desenvolvimento dos
  predicados foi limitado para fornecer o mínimo necessário para proporcionar
  procedimentos básicos de formatação. Como resultado, não foram considerados
  mecanismos de formatação mais sofisticados, como a formatação condicional, no
  escopo deste projeto.

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %% The Source Code Formatting %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \chapter{A Formatação de Código-Fonte}
  \label{chapter:src-fmt}

  Desde os primórdios da computação, métodos foram desenvolvidos para garantir
  que a saída impressa fosse formatada de maneira esteticamente agradável
  \apud{harris-1956-keyboard}[1]{yelland-2015-rfmt}. Esses métodos ganharam
  popularidade sob o termo \textit{``\gloss{prettyprinting}''}, que se refere à
  formatação visual de diversos tipos de conteúdo. No desenvolvimento de
  software, o \textit{prettyprinting} é conhecido como formatação de código,
  uma prática histórica e comum que envolve a adoção de convenções estilísticas
  para estruturar o código-fonte. Existem diversas terminologias utilizadas
  para se referir às ferramentas que realizam a formatação do código-fonte,
  incluindo:
  \begin{inparaenum}
    \item ``formatadores de código'', ou \textit{``code formatters''} em
          inglês;
    \item \textit{``prettyprinters''}; ou ainda
    \item \textit{``beautifiers''}.
  \end{inparaenum}

  \newsavebox\mexpressionexample
  \begin{lrbox}{\mexpressionexample}
    \codesnippetinline{car[cons[A; B]]}[fontsize=\footnotesize]
  \end{lrbox}

  \newsavebox\sexpressionexample
  \begin{lrbox}{\sexpressionexample}
    \codesnippetinline[lisp]{(car (cons A B))}[fontsize=\footnotesize]
  \end{lrbox}

  Durante as décadas de 60 e 70, a linguagem de programação LISP%
  \footnote
    { O termo ``LISP'' (acrônimo para
      \textit{``\textbf{LIS}t \textbf{P}rocessing''}) inicialmente se referia à
      linguagem de programação desenvolvida por
      \textcite{mccarthy-1960-recursive}, porém, com a disseminação de dialetos
      da linguagem, o termo também passou a ser utilizado para se referir à
      família de linguagens derivadas da original.}
  proporcionou condições favoráveis para o avanço da formatação de código
  \cite[2]{yelland-2015-new}.
  \begin{inparaenum}
    \item LISP apresentava uma sintaxe distinta e expressiva, baseada em listas
          e estruturas aninhadas delimitadas por parênteses%
          \footnote
            { Na notação original de McCarthy, eram utilizadas
              \textit{M-expressions} entre colchetes para representar
              expressões. Essas \textit{M-expressions} seriam posteriormente
              traduzidas em \textit{\gloss[Word]{sexp}s}. Por exemplo, a
              \textit{M-expression} \usebox{\mexpressionexample} seria
              equivalente à \textit{S-expression} \usebox{\sexpressionexample}.
              No entanto, assim que a linguagem LISP foi implementada, os
              programadores prontamente adotaram o uso das
              \textit{S-expressions} em vez das \textit{M-expressions},
              tornando as \textit{S-expressions} a forma predominante de
              representar a estrutura do código na linguagem.}%
          , o que tornava o código-fonte praticamente ilegível e
          incompreensível caso não fosse devidamente organizado. Além disso,
    \item LISP era \gloss{homoiconic}, ou seja, permitia a manipulação do
          código via dados da própria linguagem.
  \end{inparaenum}
  Essas duas características intrínsecas do LISP fundamentaram o surgimento de:
  \begin{inparaenum}
    \item \textit{prettyprinters} para a linguagem, visando aperfeiçoar a
          legibilidade do código-fonte escrito ou emitido; além de
    \item novas técnicas e abordagens para a formatação de código em geral.
  \end{inparaenum}
  Esses avanços contribuíram significativamente para o conhecimento e o
  aprimoramento de práticas de formatação de código em trabalhos subsequentes.

  Em 1967, Bill Gosper desenvolveu o \textit{GRINDEF} (acrônimo para
  \textit
    {%
      ``\textbf{GRIND}%
      \footnote
        { O termo \textit{``grind''} era utilizado em alguns círculos de LISP
          como sinônimo para \textit{prettyprinters}.}
      \textbf{F}unction''}%
  ): considerado o primeiro \textit{prettyprinter} a mensurar o tamanho das
  linhas e ter ciência de sua localização no arquivo
  \cites{gosper-2023-twubblesome}{griesemer-2022-cultural}. Essa ferramenta
  implementava o algoritmo \textit{recursive re-predictor}, que, como descrito
  por \textcite{goldstein-1973-pretty}, percorria a árvore de nós representando
  as listas e imprimia os nós considerando seus tamanhos e a quantidade máxima
  de caracteres que ainda poderiam ser inseridos em uma linha. Isso era
  especialmente relevante, uma vez que os sistemas de computação daquela época
  apresentavam restrições técnicas quanto à quantidade máxima de caracteres em
  uma linha (\textit{\gloss[short]{cpl}}) \cite{wiki-2023-characters}.

  Posteriormente, \textcite{hearn-1979-one} propuseram um algoritmo mais
  elaborado para \textit{prettyprinting} que utilizava um par de corrotinas%
  \footnote
    { Na obra, os autores enfatizam que a implementação com o uso de corrotinas
      é tão simples que poderia ser simulada --- sem grandes dificuldades ---
      em linguagens que não possuíam suporte nativo para corrotinas
      \cite[53]{hearn-1979-one}.}%
  :
  \begin{inparaenum}
    \item uma responsável por produzir uma sequência de caracteres que
          representavam o programa sendo impresso; e
    \item outra responsável por decidir como esses caracteres seriam exibidos.
  \end{inparaenum}
  Essas corrotinas se comunicavam por meio de um buffer \gloss{fifo},
  permitindo que as decisões de formatação fossem adiadas até que houvesse
  informações suficientes disponíveis para tomá-las com confiabilidade.

  No ano seguinte, \textcite{oppen-1980-prettyprinting} apresentou em sua
  influente obra, intitulada \textit{``Prettyprinting''}, um algoritmo inovador
  de formatação de código-fonte. Embora apresentasse semelhanças ao algoritmo
  proposto por \textcite{hearn-1979-one}, destacava-se por sua capacidade de
  formatar código derivado de qualquer linguagem de programação. Para realizar
  essa tarefa, o algoritmo necessitava que o código-fonte fosse anotado com
  espaços em branco%
  \footnote
    { Quebras de linha, avanços de formulário e alimentações de linha também
      eram tratados como espaços em branco pelo algoritmo.}
  e delimitadores especiais para marcar o início e fim de blocos logicamente
  contíguos. Assim, o código a ser fornecido ao algoritmo precisaria ser
  processado por uma ferramenta intermediária capaz de compreender a sintaxe da
  linguagem e fornecer um código anotado de forma adequada, permitindo que o
  algoritmo realizasse a formatação apropriada.

  Desde então, diversos trabalhos têm contribuído significativamente para a
  formatação de código-fonte. Entre esses, o trabalho de
  \textcite{yelland-2015-new} descreveu um algoritmo integrado em seu
  formatador projetado para a linguagem R \cite{yelland-2015-rfmt}. Esse
  algoritmo visa otimizar o layout do código em relação a uma noção intuitiva
  de custo de layout. Na sua obra, Yelland detalha os fundamentos desse
  algoritmo, além das abstrações de programação empregadas para facilitar sua
  aplicação em diversas linguagens e políticas de layout de código.
  Notavelmente, entre essas abstrações, destacam-se os \textit{combinators}:
  funções geradoras que descrevem layouts alternativos para o código-fonte.

  Recentemente, tem se tornado cada vez mais evidente a crescente relevância
  dos softwares opinativos \cite{eccles-2015-rise}, também conhecidos em inglês
  como \textit{\gloss{opinionated} softwares}. Esses softwares preestabelecem
  práticas estritivas, visando deliberadamente frustrar ou dificultar práticas
  destoantes \cite{lance-2021-about}. Similarmente, os \textit{prettyprinters}
  primitivos, tais como o SOAP \cite{scowen-1971-soap}, eram naturalmente
  restritivos devido à simplicidade e às limitações dos algoritmos de
  formatação existentes. Conforme mencionado, à medida que os algoritmos de
  formatação de código-fonte eram aprimorados, tornando-se mais robustos e
  sofisticados, os \textit{prettyprinters} passaram a proporcionar mais
  personalizações aos usuários. No entanto, atualmente, a abordagem opinativa
  também tem sido adotada por softwares modernos de formatação de código-fonte
  \cites{black-2023-black}[5--6,8]{griesemer-2022-cultural}. Esses softwares
  geralmente têm como objetivos:
  \begin{inparaenum}
    \item padronizar e
    \item garantir a consistência do código; além
    \item eliminar o tempo e esforços necessários para escolher os estilos
          ideais de formatação; e, final, consequente e principalmente,
    \item aprimorar o ambiente de desenvolvimento colaborativo.
  \end{inparaenum}

  Um exemplo proeminente de \textit{prettyprinter} opinativo é o
  \textit{\textbf{Black}} \cite{black-2023-black}, um formatador de código
  Python, cuja logomarca parodia a da fabricante automobilística Ford, e cujo
  irônico slogan \textit{\textbf{``any color you like''}} faz alusão à famosa
  frase
  \textit
    {%
      ``any customer can have a car painted \textbf{any colour that he wants so
      long as it is black}''}
  \cite[p. 72, grifo nosso]{ford-1922-my}, dita por Henry Ford, o fundador da
  fabricante. Assim como Ford adotou uma abordagem de produção em massa na
  fabricação dos \textit{Model Ts} com uma única opção de cor para aumentar a
  eficiência \cite{ford-1922-my}, o \textit{Black} segue um princípio análogo.
  Ao impor um estilo estrito de formatação, minimizando o espaço para
  personalização ou preferências individuais, o \textit{Black} oferece
  velocidade, determinismo, além de economia de tempo e esforços para questões
  mais importantes \cite{black-2023-black}.

  Sumarizando, desenvolver um \textit{prettyprinter} não é uma tarefa simples
  \cite[55]{hughes-1995-design}. Durante o processo de formatação, é necessário
  \begin{inparaenum}
    \item ter conhecimento das estruturas gramaticais da linguagem específica
          em questão. Além disso, o objetivo do \textit{prettyprinter} é
    \item \label{item:format} formatar o código de maneira otimizada e
          agradável para o leitor \cite[55]{hughes-1995-design}, levando em
          consideração as melhores práticas de formatação. Em alguns casos,
          também é importante
    \item permitir que o usuário possa optar por estilos de formatação que
          atenda às suas preferências individuais. Adicionalmente, as sintaxes
          das linguagens de programação costumam ser flexíveis em relação à
          estruturação do código-fonte. Assim, para atender o
          \cref{item:format}, geralmente é necessário
    \item utilizar algoritmos que calculem o layout mais adequado de acordo com
          o contexto
          \cites
            [12]{jasper-2023-clang}
            {goldstein-1973-pretty}
            {hughes-1995-design}
            {yelland-2015-new}.
  \end{inparaenum}
  Fatalmente, essas características essenciais de um \textit{prettyprinter}
  normalmente o restringem a uma linguagem específica ou, em alguns casos, a
  uma família de linguagens que compartilham semelhanças sintáticas ou
  estruturais.

  %%%%%%%%%%%%%%%%%%%%%%%%%%%
  %% The Tree-Sitter System %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%

  \chapter{O Sistema \treesitter}
  \label{chapter:tree-sitter}

  O \treesitter é um sistema multilíngue de análise sintática para ferramentas
  de programação inicialmente desenvolvido como um projeto secundário por Max
  Brunsfeld. Como relatado pelo próprio autor \cite{github-2017-tree}, o
  \treesitter surgiu como uma tentativa de solucionar problemas presentes nas
  ferramentas de análise sintática da época. Mais especificamente, o sistema
  tinha como objetivos:
  \begin{inparaenum}
    \item ser utilizado no ambiente de desenvolvimento para produzir árvores de
          sintaxe a partir da análise de códigos escritos em várias linguagens;
    \item implementar a análise incremental, permitindo a atualização da árvore
          de sintaxe em tempo real;
    \item expor através da árvore de sintaxe os nós representando suas
          construções gramaticais no código (e.g., classes, funções,
          declarações, etc.), diferentemente das ferramentas contemporâneas,
          que utilizavam uma abordagem simplística baseada em expressões
          regulares; e, por fim,
    \item ser livre de dependências, assim beneficiando sua adoção e
          aplicabilidade.
  \end{inparaenum}

  Além das funcionalidades previamente mencionadas presentes no \treesitter, o
  sistema também conta uma ferramenta de linha de comando que pode ser
  utilizada para gerar \textit{\gloss{parser}s} para uma linguagem a partir de
  sua gramática. A gramática é definida via a linguagem de programação
  JavaScript, a qual:
  \begin{inparaenum}
    \item foi eleita 15 vezes seguidas pela
          \textit{Stack Overflow Developer Survey}
          \cite{stack-overflow-2022-stack} como a linguagem de programação mais
          comumente usada; além de
    \item ser amplamente considerada pela comunidade de programadores como uma
          das linguagens mais fáceis de aprender e programar
          \cites{berkeley-2023-11}{goel-2023-how}{w3schools-2023-javascript}.
  \end{inparaenum}
  A ferramenta de geração de \textit{parsers} também disponibiliza funções
  preestabelecidas para permitir a criação de gramáticas com diferentes níveis
  de complexidade. Não é surpreendente que, devido a essas características e
  facilidades presentes na criação de \textit{parsers}, exista uma variedade de
  linguagens de programação e formatos de arquivos --- variando de linguagens
  com sintaxes complexas, como C++ e Perl, a formatos de arquivos mais
  específicos, como \codesnippetinline{.vhs} e \codesnippetinline{.rasi} ---,
  os quais têm parsers gerados pelo \treesitter e, consequentemente, são
  suportados pelo sistema.

  Na análise de código, é comum realizar tarefas que envolvem a busca de
  padrões na árvore sintática. Para isso, o \treesitter oferece uma pequena
  linguagem de consulta declarativa que é capaz de expressar esses padrões por
  meio de \textit{\gloss[Word]{sexp}s} e buscar correspondências. A linguagem
  de consulta suporta operadores que permitem:
  \begin{inparaenum}
    \item a captura de nós;
    \item a quantificação de nós, análoga às expressões regulares;
    \item o agrupamento de nós;
    \item as alternâncias de nós;
    \item o uso de \textit{\gloss{wildcard}s}; e
    \item a ordenação de nós.
  \end{inparaenum}
  Adicionalmente, é permitido o uso de predicados --- funções arbitrárias
  geralmente utilizadas para filtrar nós ou realizar verificações mais
  complexas durante a busca de padrões ---, sejam eles
  \textit{\gloss{builtin}s} ou estendidos por meio de uma API.

  Um exemplo da relevância e utilidade da linguagem de consulta é o plugin
  \textit{nvim-treesitter} \cite{nvim-treesitter-2023-nvim}, que é
  frequentemente utilizado no editor \textit{Neovim}
  \cite{neovim-2023-hyperextensible}. Esse plugin utiliza a linguagem de
  consulta para definir diferentes recursos, tais como:
  \begin{inparaenum}
    \item \textit{\gloss{code-folding}}, que permite ocultar blocos de código;
    \item highlights, que realçam a sintaxe do código;
    \item indentações, que definem a estrutura do código;
    \item injeções, que permitem adicionar novas sintaxes a arquivos
          existentes; além de
    \item captura de nós correspondentes a construções gramaticais (e.g.,
          funções, classes, métodos, etc.), os quais são frequentemente
          utilizados em rotinas de programação tais como a remoção e navegação
          de código.
  \end{inparaenum}

  Em resumo, o sistema \treesitter se mostra uma solução inovadora e eficiente
  para a análise sintática de códigos em diversas linguagens de programação,
  com uma abordagem diferenciada e sofisticada que possibilita a atualização em
  tempo real da árvore sintática e a identificação precisa das construções
  gramaticais presentes no código. Além disso, a ferramenta de linha de comando
  disponível no sistema facilita a geração de parsers a partir de gramáticas
  definidas em JavaScript, o que torna o processo mais acessível e
  personalizável para os programadores. Finalmente, a linguagem de consulta
  declarativa oferecida pelo \treesitter se mostra uma importante
  \textit{\gloss{feature}}, sendo utilizada em diversos plugins de editores de
  código para realizar tarefas variadas e sofisticadas, contribuindo
  significativamente no ambiente de desenvolvimento.

  %%%%%%%%%%%%%%%%%%%%%%
  %% The Witch Cooking %
  %%%%%%%%%%%%%%%%%%%%%%

  \chapter{O \witchcooking}
  \label{chapter:witch}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Motivations and Purposes %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Motivações e Propósitos}

  As motivações para o desenvolvimento do \witchcooking surgiram das
  dificuldades enfrentadas pelo autor ao estudar estilos de formatação de
  código-fonte em diversas linguagens de programação com as quais ele
  trabalhava. O estudo envolvia a exploração e análise tanto de estilos
  convencionais%
  \footnote
    { Neste trabalho, são considerados convencionais os estilos de formatação
      abordados nas páginas \textit{Indentation style} e
      \textit{Programming style} da Wikipédia.
      \cites{wiki-2023-indentation}{wiki-2023-programming}}%
  , dos quais muitos eram amplamente adotados, quanto de estilos
  não convencionais. Durante a análise dos estilos convencionais de formatação,
  \begin{inparaenum}
    \item era imprescindível recorrer a diferentes \textit{prettyprinters},
    \item cada um com suas próprias configurações e níveis de suporte para
          esses estilos. Por outro lado, durante a análise dos estilos
          não convencionais,
    \item a aplicação manual era inevitável, consumindo consideravelmente tempo
          e esforço.
  \end{inparaenum}

  Tendo em vista
  \begin{inparaenum}
    \item as dificuldades mencionadas anteriormente, além da
    \item complexidade envolvida no \textit{prettyprinting} ---
    \item agravada pela proposta de formatação multilíngue ---,
  \end{inparaenum}
  o \witchcooking foi concebido como um software de linha de comando --- de
  natureza prototípica --- para a formatação de código-fonte. A ferramenta
  elaborada tem como objetivos:
  \begin{inparaenum}
    \item abranger uma gama de linguagens de programação e
    \item proporcionar a formatação personalizada via a linguagem de consulta
          do \treesitter.
  \end{inparaenum}

  %%%%%%%%%%%%%%%
  %%% Materials %
  %%%%%%%%%%%%%%%

  \section{Materiais}

  O \witchcooking foi programado em Rust \cite{rust-2023-rust}, que é uma
  linguagem amplamente reconhecida na comunidade de programadores
  \cite{stack-overflow-2023-stack}. Dentre os motivos que levaram à escolha
  dessa linguagem para o desenvolvimento, destacam-se:
  \begin{inparaenum}
    \item seu gerenciamento de memória seguro%
          \footnote
            { Embora Rust não apresente \textit{\gloss{garbage-collection}} ---
              o que contribui significativamente para o desempenho ---, a
              linguagem emprega \textit{features} e conceitos como
              \textit{borrow checker}, \textit{ownership} e \textit{lifetime},
              garantindo um gerenciamento de memória seguro. Isso é
              especialmente relevante em linguagens de alto desempenho que não
              possuem coleta de lixo (e.g., C e C++). Estudos estimam que,
              nesse contexto, pelo menos 65\% das vulnerabilidades de segurança
              sejam causadas por falta de segurança no gerenciamento de memória
              \cite{gaynor-2020-what}.}
          \cite[3]{nsa-2022-software};
    \item seu excelente desempenho, a par às linguagens C e C++;
    \item seus recursos de linguagens modernas, incluindo
          \begin{inparaenum}
            \item expressividade,
            \item \textit{\gloss{zero-cost-abs}},
            \item correspondência de padrões,
            \item \textit{closures},
            \item macros, etc.;
          \end{inparaenum}
    \item seu suporte a múltiplas plataformas; além de
    \item seu ecossistema de desenvolvimento fértil, que oferece
          \begin{inparaenum}
            \item uma ampla variedade de bibliotecas,
            \item \textit{Cargo} \cite{rust-2023-cargo}, o gerenciador de
                  pacotes, além do
            \item \textit{rust-analyzer} \cite{rust-analyzer-2023-rust}, uma
                  implementação do \textit{Language Server Protocol} (LSP) para
                  a linguagem.
          \end{inparaenum}
  \end{inparaenum}

  Para atender a seus objetivos, o \witchcooking foi desenvolvido com base no
  sistema \treesitter \cite{tree-sitter-2023-tree}, o qual:
  \begin{inparaenum}
    \item suporta uma ampla variedade de linguagens de programação e formatos
          de arquivos, além de
    \item possuir uma linguagem de consulta versátil e extensível que, dentre
          outras características, permite
          \begin{inparaenum}
            \item a realização de buscas complexas na árvore de sintaxe
                  analisada de um código-fonte, bem como
            \item a adição de predicados personalizados.
          \end{inparaenum}
  \end{inparaenum}

  Para escrever o código do \witchcooking, foi utilizado o editor de texto
  \textit{Neovim} \cite{neovim-2023-hyperextensible}, com configurações
  personalizadas \cite{silva-2023-uma}. Essas configurações possibilitaram a
  integração com o \textit{rust-analyzer}, o que resultou em melhorias
  significativas na experiência de programação. Dentre os plugins utilizados na
  configuração, destacam-se:
  \begin{inparaenum}
    \item o \textit{nvim-treesitter} \cite{nvim-treesitter-2023-nvim}, que
          permitiu a integração com o \treesitter; além do
    \item \textit{playground} \cite{nvim-treesitter-2023-playground}, que
          disponibilizou ferramentas para uma melhor compreensão do \treesitter
          e de sua linguagem de consulta.
  \end{inparaenum}

  %%%%%%%%%%%%%
  %%% Methods %
  %%%%%%%%%%%%%

  \section{Métodos}

  Embora o \treesitter não tenha sido originalmente projetado para formatação
  de código-fonte, o autor deste trabalho identificou o potencial do sistema,
  particularmente em relação à sua linguagem de consulta, que ---
  como já ressaltado --- é extensível. Assim, para permitir a formatação
  dirigida, o \witchcooking baseou-se na extensão e disponibilização de
  predicados designados a executar operações específicas de formatação. Em
  outras palavras, a concepção do autor era que a formatação ocorresse conforme
  a aplicação dos predicados estendidos em padrões especificados no arquivo
  contendo as diretrizes de formatação, escrito na linguagem de consulta do
  \treesitter.

  Devido à natureza prototípica do software desenvolvido, foi adotada uma
  abordagem multifacetada neste trabalho. Inicialmente, foi conduzida
  \begin{inparaenum}
    \item uma pesquisa bibliográfica que abrangeu termos-chave como:
          \begin{inparaenum}
            \item \textit{``code formatting''},
            \item \textit{``Tree-Sitter''},
            \item \textit{``programming style''}, e
            \item \textit{``style guide''}.
          \end{inparaenum}
          Complementarmente, foi feita
    \item uma pesquisa documental, que fundamentou a compreensão das
          tecnologias e bibliotecas --- em especial, o \treesitter{} ---
          utilizadas no desenvolvimento do \witchcooking.

          À medida que se aprofundou o conhecimento sobre o \treesitter, foram
          incorporados elementos de
    \item uma pesquisa experimental com o objetivo de explorar a aplicação do
          sistema como base para o algoritmo de formatação de código-fonte.
          Similarmente, foram integrados elementos de
    \item um estudo de caso com o propósito de analisar a eficácia do software
          desenvolvido.
  \end{inparaenum}

  %%%%%%%%%%%
  %%% Usage %
  %%%%%%%%%%%

  \section{Usagem}
  \label{section:usage}

  O \witchcooking apresenta a seguinte usagem
  \codesnippetinline{cook [-l LANG] -q QUERY [SRC]}%
  , onde:
  \begin{inparaenum}
    \item \codesnippetinline{cook} é o nome do executável,
    \item \codesnippetinline{[-l LANG]} é uma opção para explicitar a linguagem
          do código-fonte a ser formatado,
    \item \codesnippetinline{-q QUERY} é utilizado para definir o caminho para
          o arquivo --- escrito na linguagem de consulta do \treesitter{} ---
          no qual as diretrizes de formatação estão definidas, e
    \item \codesnippetinline{[SRC]} é um argumento opcional para especificar o
          caminho para o arquivo a ser formatado.
  \end{inparaenum}
  Quando \codesnippetinline{[SRC]} é provido e \codesnippetinline{[-l LANG]} é
  omitido, o software tentará inferir uma linguagem conforme a extensão do nome
  do arquivo. Por outro lado, quando \codesnippetinline{[SRC]} é omitido, o
  código-fonte a ser formatado deve ser provido via \textit{\gloss{pipeline}},
  e a sua linguagem deve ser explicitada via \codesnippetinline{[-l LANG]}. Em
  alinhamento com sua natureza experimental, o \witchcooking proporciona o
  código-fonte formatado resultante como saída, sem modificar o conteúdo
  original, efetivamente estabelecendo uma formatação segura.

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% The Formatting Algorithm %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{O Algoritmo de Formatação}
  \label{section:fmt-algorithm}

  O \witchcooking permite a formatação de código-fonte via seu algoritmo
  fundamentado no \treesitter e sua linguagem de consulta. Esse algoritmo
  utiliza o sistema para gerar uma árvore de sintaxe a partir do código-fonte
  submetido pelo usuário. Adicionalmente, complementando os predicados
  \textit{builtins} do \treesitter{} --- os quais foram concebidos para a busca
  de padrões correspondentes ---, o algoritmo inclui predicados desenvolvidos
  para executar procedimentos variados de formatação. Consequentemente, ao
  utilizar esses predicados nos padrões da consulta, é possível dirigir a
  formatação de nós específicos da árvore de sintaxe.

  Para compreender esta seção e as subsequentes, é essencial ter um
  conhecimento básico sobre o funcionamento da linguagem de consulta do
  \treesitter, que é cerne do algoritmo desenvolvido. Portanto, é recomendado a
  leitura do \cref{appendix:queries}, onde são abordados os principais
  conceitos e características dessa linguagem.

  A operação do algoritmo de formatação divide-se nas etapas de:
  \begin{inparaenum}
    \item inicialização,
    \item formatação, e
    \item retorno,
  \end{inparaenum}
  como ilustrado na \cref{figure:algorithm-flowchart}. Durante a etapa de
  inicialização --- onde estruturas são instanciadas ---, primeiramente,
  \begin{inparaenum}
    \item a árvore de sintaxe --- derivada do código-fonte submetido para
          formatação --- é analisada. Em seguida,
    \item um objeto%
          \footnote
            { Neste contexto, o termo ``objeto'' é utilizado como uma
              alternativa para descrever uma estrutura em Rust.}
          de consulta é gerado a partir do arquivo contendo as
          diretrizes de formatação, escrito na linguagem de consulta do
          \treesitter. Esse objeto:
          \begin{inparaenum}
            \item contém informações sobre padrões, capturas, propriedades e
                  predicados; e
            \item é posteriormente utilizado para obter as correspondências
                  dos seus padrões.
          \end{inparaenum}

          Além disso,
    \item é instanciada uma estrutura editora que contém:
          \begin{inparaenum}
            \item o texto do código-fonte em edição --- originado do código
                  submetido pelo usuário ---, juntamente com
            \item um vetor de edições.
          \end{inparaenum}
          Essa estrutura é utilizada pelos predicados para realizar edições no
          código. Na sequência,
    \item é inicializado um objeto de configurações, que é futuramente
          empregado pelos predicados para obter e definir configurações em
          diferentes níveis de escopo, sejam eles globais --- i.e., abrangendo
          toda a consulta --- ou locais --- i.e., restrito a um padrão.
          Finalizando a etapa de inicialização,
    \item a estrutura de correspondências é derivada:
          \begin{inparaenum}
            \item do objeto de consulta, juntamente com
            \item a árvore analisada e
            \item o texto do código-fonte submetido.
          \end{inparaenum}
          Simplificadamente, essa estrutura pode ser descrita como um iterador
          que fornece nós que correspondem a capturas presentes em padrões
          específicos.
  \end{inparaenum}

  O processo efetivo de formatação de código-fonte inicia na segunda etapa.
  Nessa fase, a dinâmica se baseia em
  \begin{inparaenum}
    \item \label{item:pattern-loop} um \textit{\gloss{loop}} que itera sobre
          todos os padrões especificados no arquivo contendo as diretrizes de
          formatação. Em cada iteração, inicialmente,
    \item é checado se o padrão é enraizado%
          \footnote
            { Na linguagem de consulta do \treesitter, embora o sistema não
              forneça uma definição exata, um padrão enraizado é geralmente
              caracterizado por especificar pelo menos um nó inicial para a
              correspondência, e vice-versa.}
          ou não, determinando assim se o escopo de atuação do padrão é local
          ou global, respectivamente. Em seguida,
    \item \label{item:nodes-loop} um segundo \textit{loop} percorre as coleções
          de nós capturados para cada correspondência do padrão em questão. No
          corpo dessa estrutura de repetição,
    \item são aplicadas as configurações especificadas no padrão via o
          predicado \textit{builtin} \codesnippetinline{set!}. Além disso,
    \item são aplicados os predicados gerais --- i.e., predicados não
          \textit{builtins} --- especificados no padrão em iteração.
          Pressupõe-se que esses predicados estejam dentre os providos pelo
          \witchcooking para dirigir a formatação.

          Encerrando o \cref{item:nodes-loop} e, subsequentemente, o
          \cref{item:pattern-loop}, bem como a etapa de formatação como um
          todo,
    \item as configurações locais --- i.e, configurações a nível de
          correspondência --- são redefinidas para seus valores padrões. Logo
          em seguida,
    \item é interrompido o \cref{item:nodes-loop} caso o padrão em iteração não
          seja enraizado.
  \end{inparaenum}
  Por fim, na etapa de retorno, o algoritmo conclui retornando o código-fonte
  resultante do processo de formatação.

  { \centering
    \figurewrapper
      {Fluxograma do Algoritmo de Formatação}
      {algorithm-flowchart}
      { \tiny
        \begin
          {tikzpicture}
          [node distance=1em,every node/.style={draw,inner sep=1em}]
          \node (init) {
            \begin
              {tikzpicture}
              [ every node/.style=
                  {align=center,draw,inner sep=.5em,text width=16em}]
              \node [draw=none] (label) {Inicialização};
              \node (I) [below=of label] {Analisa a árvore de sintaxe};
              \node (II) [below=of I] {Gera o objeto de consulta};
              \node (III) [below=of II] {Instancia a estrutura editora};
              \node (IV) [below=of III] {Inicializa o objeto de configurações};
              \node (V) [below=of IV] {Deriva a estrutura de correspondências};
              \draw [->] (I) -- (II);
              \draw [->] (II) -- (III);
              \draw [->] (III) -- (IV);
              \draw [->] (IV) -- (V);
            \end{tikzpicture}
          };
          \node (fmt) [below=of init] {
            \begin
              {tikzpicture}
              [ every node/.style=
                  {align=center,draw,inner sep=.5em,text width=14em}]
              \node [draw=none,text width=16em] (label) {Formatação};
              \path
                let \p1=(label.south)
                in coordinate (I-coord) at ($ (\x1-1em,\y1-1em) $);
              \node (I) at (I-coord) {Itera sobre os padrões};
              \node (II) [below=of I] {Define o escopo de atuação};
              \node
                (III)
                [below=of II]
                {Itera sobre as coleções\\de nós capturados};
              \node (IV) [below=of III] {Aplica as configurações};
              \node (V) [below=of IV] {Aplica os predicados gerais};
              \node (VI) [below=of V] {Redefine as\\configurações locais};
              \node
                (VII)
                [below=of VI]
                {Interrompe o \cref{item:nodes-loop} se o padrão é enraizado};
              \draw [->] (I) -- (II);
              \draw [->] (II) -- (III);
              \draw [->] (III) -- (IV);
              \draw [->] (IV) -- (V);
              \draw [->] (V) -- (VI);
              \draw [->] (VI) -- (VII);
              \draw [->] (VII.east) -- ++(1em,0) |- (III.east);
              \draw [->] (VII.east) -- ++(2em,0) |- (I.east);
            \end{tikzpicture}
          };
          \draw [->] (init) -- (fmt);
          \node (ret) [below=of fmt] {
            \begin
              {tikzpicture}
              [ every node/.style=
                  {align=center,draw,inner sep=.5em,text width=16em}]
              \node [draw=none] (label) {Retorno};
              \node
                (label)
                [below=of label]
                {Retorna o código-fonte formatado};
            \end{tikzpicture}
          };
          \draw [->] (fmt) -- (ret);
        \end{tikzpicture}}
    \vspace{-2ex}
    \captionof*{figure}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% The Formatting Guidelines %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{As Diretrizes de Formatação}
  \label{section:guidelines}

  Como já enfatizado em diversas ocasiões, as diretrizes de formatação do
  código-fonte são especificadas no arquivo escrito na linguagem de consulta do
  \treesitter, o qual é submetido ao \witchcooking via
  \codesnippetinline{-q QUERY}. Para realizar um procedimento de formatação, é
  necessário:
  \begin{inparaenum}
    \item definir um padrão de correspondência que delimita o escopo de
          operação;
    \item capturar nós que
          \begin{inparaenum}
            \item sejam alvos do procedimento --- i.e., serão formatados --- ou
            \item auxiliarão nas operações;
          \end{inparaenum}
    \item opcionalmente, aplicar configurações via o predicado
          \codesnippetinline{set!}; e, por fim,
    \item aplicar os predicados estendidos pelo \witchcooking.
  \end{inparaenum}

  Uma das operações fundamentais de formatação consiste na inserção de
  espaçamento entre \textit{\gloss{token}s}. Nesse contexto, o \witchcooking
  disponibiliza o predicado \codesnippetinline{space!}. Esse predicado funciona
  da seguinte forma \codesnippetinline{(#space! [sep [lower [upper]]] a b)},
  onde
  \begin{inparaenum}
    \item \codesnippetinline{a} e \codesnippetinline{b} são duas capturas que
          se deseja separar;
    \item \codesnippetinline{sep} é uma string opcional que determina a
          sequência de caracteres utilizada para separar os nós capturados,
          sendo o caractere de espaço o valor padrão; e
    \item \codesnippetinline{lower} e \codesnippetinline{upper} são inteiros
          não negativos opcionais que definem o intervalo inclusivo para a
          não operação do espaçamento, sendo que
          \begin{inparaenum}
            \item se ambos forem especificados, o intervalo será
                  $ \left
                      [ \codesnippetinline{lower},
                        \codesnippetinline{upper}\right]$%
                  , caso contrário,
            \item se somente \codesnippetinline{lower} for especificado, o
                  intervalo resultante será
                  $\left[1, \codesnippetinline{lower}\right]$%
                  , senão,
            \item caso ambos forem ausentes, o intervalo de não operação é
                  nulo. Além disso,
            \item quando o intervalo de não operação é definido, a separação
                  dos nós é evitada se a sequência de caracteres entre eles
                  contiver uma quantidade de \codesnippetinline{sep} que esteja
                  dentro do intervalo especificado.
          \end{inparaenum}
  \end{inparaenum}

  Para ilustrar o funcionamento do predicado \codesnippetinline{space!},
  considere o seguinte vetor na linguagem de programação Rust, apresentado no
  seguinte trecho de código em linha: \codesnippetinline[rust]{[0,1,   2,  3]}.
  Para formatar esse vetor, de modo que cada número após uma vírgula seja
  separado por um espaço, é possível usar a consulta exibida no
  \cref{snippet:scheme:rust:vec-items-sep}. Ao formatar o vetor com essa
  consulta, é obtido \codesnippetinline[rust]{[0, 1, 2, 3]}, conforme esperado.
  No padrão presente na consulta usada para formatar o vetor, o predicado
  \codesnippetinline{space!} é chamado com a configuração de argumentos mais
  simples, que consiste em especificar apenas as capturas que devem ser
  separadas.

  \noindent
  \begin{minipage}[t]{\textwidth}
    \begin
      {codesnippet}%
      [scheme]%
      {Consulta para Separar Elementos de um Vetor em Rust}%
      {rust:vec-items-sep}
      (array_expression
        "," @comma
        . (_) @item
        (#space! @comma @item))
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  Outro exemplo típico de inserção de espaçamento usado na formatação de
  código-fonte é o espaçamento entre elementos pertencentes ao corpo de uma
  função. Nesse contexto, é comum seprar esses elementos com uma quebra de
  linha. Contudo, em certos casos, são utilizadas duas quebras de linha para
  destacar diferentes blocos de código, a fim de favorecer a compreensão do
  leitor. Para ilustrar, considere o \cref{snippet:rust:let-decl-cluster}, que
  contém dois blocos dentro de uma função. No primeiro bloco de código, é
  possível notar o arranjo da linha 3, que contém duas
  \textit{let declarations}. Para formatar o corpo da função, desaglomerando as
  \textit{let declarations} e mantendo o espaçamento que separa os blocos, é
  possível utilizar a consulta mostrada no
  \cref{snippet:scheme:rust:fn-body-items-sep}.

  \noindent
  \begin{minipage}[t]{\halftextwidthplustwoemcounterpart}
    \begin
      {codesnippet}%
      [rust]%
      {Função Com Bloco Aglomerado em Rust}%
      {let-decl-cluster}%
      [fontsize=\ABNTEXfontereduzida]
      fn x_plus_y() -> u32 {
        let x = 5; let y = 11;

        x + y
      }
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}
  \hfill
  \noindent
  \begin{minipage}[t]{\halftextwidthplustwoempart}
    \begin
      {codesnippet}%
      [scheme]%
      {Consulta para Separar Elementos do Corpo de uma Função em Rust}%
      {rust:fn-body-items-sep}%
      [fontsize=\ABNTEXfontereduzida]
      (function_item
        body: (block (_) @item . (_) @next)
        (#space! "\n" 2 @item @next))
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  Essa consulta apresenta um padrão que aplica o predicado
  \codesnippetinline{space!} com uma configuração de argumentos mais elaborada.
  Primeiramente, em adição ao \cref{snippet:scheme:rust:vec-items-sep},
  \begin{inparaenum}
    \item é especificada a string \codesnippetinline{sep} com o valor
          \codesnippetinline{"\n"}, indicando que os itens do corpo da função
          serão separados por uma quebra de linha. Além disso,
    \item é especificado o limite inferior \codesnippetinline{lower} como 2,
          resultando num intervalo de não aplicação de $\left[1, 2\right]$.
          Em termos mais simples, isso implica que itens já separados por uma
          ou duas quebras de linha não sofrerão alterações, o que, por sua vez,
          mantém a formatação dos blocos intacta.
  \end{inparaenum}

  Desta forma, ao aplicar a consulta do
  \cref{snippet:scheme:rust:fn-body-items-sep} ao
  \cref{snippet:rust:let-decl-cluster}, obtém-se o código-fonte formatado,
  conforme ilustrado no \cref{snippet:rust:bad-indent}. Embora o uso de quebras
  de linha para separar elementos do corpo da função esteja correto,
  observa-se um erro de indentação na linha 4. Isso ocorre porque o predicado
  \codesnippetinline{space!} lida com a separação dos itens de sintaxe, mas não
  controla a indentação deles. No entanto, para lidar com a indentação, é
  possível combinar os predicados \codesnippetinline{set!} e
  \codesnippetinline{indent!}, como demonstrado no
  \cref{snippet:scheme:rust:fn-body-items-sep-with-indent}.

  \noindent
  \begin{minipage}[t]{\halftextwidthplustwoemcounterpart}
    \begin
      {codesnippet}%
      [rust]%
      {Função Com Má Indentação em Rust}%
      {bad-indent}%
      [fontsize=\ABNTEXfontereduzida]
      fn x_plus_y() -> u32 {
        let x = 5;
      let y = 11;

        x + y
      }
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}
  \hfill
  \noindent
  \begin{minipage}[t]{\halftextwidthplustwoempart}
    \begin
      {codesnippet}%
      [scheme]%
      { Consulta para Separar Elementos do Corpo de uma Função Com Indentação
        em Rust}%
      {rust:fn-body-items-sep-with-indent}%
      [fontsize=\ABNTEXfontereduzida]
      (#set! indent-style "  ")

      (function_item
        body: (block (_) @item . (_) @next)
        (#space! "\n" 2 @item @next)
        (#set! @next indent-rule "+1")
        (#indent! @next))
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  Na primeira linha deste trecho, observa-se um padrão composto exclusivamente
  pelo predicado \codesnippetinline{set!}, no qual a propriedade
  \codesnippetinline{indent-style} é configurada para dois caracteres de
  espaço. Conforme discutido na \cref{section:fmt-algorithm}, a ausência de um
  nó como base para correspondência classifica esse padrão como enraizado,
  implicando que a propriedade especificada terá um efeito no escopo global.
  Simplificadamente, o trecho
  \codesnippetinline[scheme]{(#set! indent-style "  ")} estabelece que, a menos
  que a configuração \codesnippetinline{indent-style} seja sobreposta
  localmente, o estilo de indentação será caracterizado como dois espaços.

  Ainda na consulta ilustrada pelo
  \cref{snippet:scheme:rust:fn-body-items-sep-with-indent}, no padrão enraizado
  pelo nó \codesnippetinline{function_item}, começado na linha 3, podem ser
  observadas duas diferenças em relação à versão anterior, exibida no
  \cref{snippet:scheme:rust:fn-body-items-sep}. Primeiramente,
  \begin{inparaenum}
    \item na linha 6, a propriedade \codesnippetinline{indent-rule} é
          configurada com o valor \codesnippetinline{"+1"} para a captura
          \codesnippetinline{@next}. Essa configuração define que, ao indentar
          os nós capturados, deverá ser utilizado o estilo de indentação
          vigente em adição ao deslocamento dos nós pais%
          \footnote
            { Tecnicamente, o deslocamento é calculado como o índice (em bytes)
              do primeiro caractere que não seja classificado como um
              \textit{ASCII whitespace} \cite{infra-2023-ascii} presente na
              linha que inicia o pai do nó capturado.}%
          . Além disso,
    \item na próxima linha, o predicado \codesnippetinline{indent!} é aplicado,
          tomando como argumento a captura \codesnippetinline{@next}. Esse
          predicado tem como função aplicar a indentação previamente
          configurada a cada nó capturado pelos argumentos passados.
  \end{inparaenum}

  Finalmente, ao aplicar uma consulta mais sofisticada --- exemplificada no
  \cref{snippet:scheme:rust:fn-body-items-sep-with-indent} --- ao
  \cref{snippet:rust:let-decl-cluster}, obtém-se o código-fonte formatado
  conforme ilustrado no \cref{snippet:rust:proper-indent}. Nesse código,
  observa-se que:
  \begin{inparaenum}
    \item os blocos de código foram preservados, bem como
    \item as \textit{let declarations} foram desaglomeradas em suas respectivas
          linhas --- e com a devida indentação ---,
  \end{inparaenum}
  atendendo às expectativas de formatação.

  \noindent
  \begin{minipage}[t]{\textwidth}
    \begin
      {codesnippet}%
      [rust]%
      {Função Com Indentação Apropriada em Rust}%
      {proper-indent}
      fn x_plus_y() -> u32 {
        let x = 5;
        let y = 11;

        x + y
      }
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  No decorrer da exemplificação do uso do predicado \codesnippetinline{space!}
  com a configuração de argumentos mais avançada, foi introduzida a
  configuração \codesnippetinline{indent-rule}. Essa configuração determina a
  regra de indentação para uma captura específica --- i.e., a designação de uma
  captura é obrigatória para essa configuração. Através do predicado
  \codesnippetinline{set!}, é possível especificar os seguintes tipos valores
  para a configuração \codesnippetinline{indent-rule}.

  Primeiramente,
  \begin{inparaenum}
    \item pode ser definido um inteiro não negativo --- sem sinal. Esse valor
          denota o nível de indentação absoluto para a captura em questão. Em
          outras palavras:
          \begin{inparaenum}
            \item se o valor for 0, os nós capturados terão nenhum deslocamento
                  em relação ao início da linha, independentemente do estilo de
                  indentação definido via \codesnippetinline{indent-style};
            \item se o valor for 1, os nós capturados serão deslocados por uma
                  string idêntica ao estilo de indentação definido;
            \item se o valor for 2, os nós capturados serão deslocados por uma
                  sequência de caracteres equivalente a duas strings
                  subsequentes do estilo de indentação; e assim por diante.
          \end{inparaenum}

          \newsavebox\querystringregex
          \begin{lrbox}{\querystringregex}
            \codesnippetinline{[-0-9a-zA-Z]}[fontsize=\footnotesize]
          \end{lrbox}

          \newsavebox\indentruleabs
          \begin{lrbox}{\indentruleabs}
            \codesnippetinline
              [scheme]
              {(#set! @node indent-rule 0)}
              [fontsize=\footnotesize]
          \end{lrbox}

          \newsavebox\indentruleneg
          \begin{lrbox}{\indentruleneg}
            \codesnippetinline
              [scheme]
              {(#set! @node indent-rule -1)}
              [fontsize=\footnotesize]
          \end{lrbox}

          \newsavebox\indentrulepos
          \begin{lrbox}{\indentrulepos}
            \codesnippetinline
              [scheme]
              {(#set! @node indent-rule "+1")}
              [fontsize=\footnotesize]
          \end{lrbox}

          Além disso,
    \item pode ser especificado um inteiro positivo --- com sinal. Esse número
          configura o nível de indentação adicional para os nós capturados,
          relativo ao deslocamento apresentado pelos pais desses nós. Dessa
          forma:
          \begin{inparaenum}
            \item se o valor for \codesnippetinline{"+1"}%
                  \footnote
                    { É importante ressaltar que, ao fornecer um argumento para
                      um predicado na linguagem de consulta do \treesitter,
                      esse argumento deve ser
                      \begin{inparaenum}[(I)]
                        \item ou uma string,
                        \item ou uma captura.
                      \end{inparaenum}
                      Para especificar uma string, é possível seguir a
                      abordagem tradicional, utilizando as aspas duplas como
                      delimitadores para a sequência de caracteres. No entanto,
                      quando cada caractere da string atende à expressão
                      regular \usebox{\querystringregex}, é possível dispensar
                      os delimitadores. Consequentemente, para configurar uma
                      regra de indentação, é possível especificar uma regra:
                      \begin{inparaenum}[(I)]
                        \item absoluta via \usebox{\indentruleabs},
                        \item relativa negativa usando \usebox{\indentruleneg},
                              e
                        \item relativa positiva com \usebox{\indentrulepos}.
                      \end{inparaenum}}%
                  , os nós capturados
                  serão deslocados mais um \codesnippetinline{indent-style}
                  além do que seus pais apresentam; já
            \item se o valor for \codesnippetinline{"+2"}, o deslocamento
                  adicional será de dois \codesnippetinline{indent-style}; e
                  assim sucessivamente.
          \end{inparaenum}

          Encerrando, dentre os diferentes tipos de valores aceitos pela
          configuração de regra de indentação (\codesnippetinline{indent-rule})
          via o predicado \codesnippetinline{set!},
    \item pode ser passado um inteiro negativo. Esse valor é usado para
          calcular o número de caracteres pelo qual os nós capturados devem
          recuar em relação ao deslocamento dos seus pais. Esse cálculo é
          efetuado multiplicando-se o módulo do valor passado pela quantidade
          de caracteres que o estilo de indentação --- definido via
          \codesnippetinline{indent-style} --- contém. Por exemplo,
          considerando que o deslocamento dos nós pais é de 4 caracteres e que
          o estilo de indentação foi definido como \codesnippetinline{"  "}
          (dois espaços):
          \begin{inparaenum}
            \item se -1 for passado, os nós capturados recuarão 2 caracteres e
                  seu deslocamento será de 2 caracteres;
            \item se o valor for -2, o recuo dos nós capturados será de 4
                  caracteres, e o deslocamento desses nós será de 0 caracteres
                  --- i.e., início da linha ---; por fim,
            \item se o número especificado for -3, ocorrerá um erro, pois o
                  recuo calculado de 6 caracteres será maior que o deslocamento
                  dos nós pais, que é de apenas 4 caracteres.
          \end{inparaenum}
  \end{inparaenum}

  Outra prática comum de formatação consiste em alinhar a indentação de um nó
  com o deslocamento de outro nó arbitrário. Para alcançar esse tipo de
  formatação, pode-se fazer uso da configuração
  \codesnippetinline{indent-rule}. No entanto, devido à natureza dessa
  operação, que requer a relação de nós de capturas distintas, o uso do
  predicado \codesnippetinline{set!} não é adequado, uma vez que esse predicado
  permite apenas atribuir uma string a uma captura. Portanto, para estabelecer
  essa relação de deslocamento entre dois nós, o \witchcooking disponibiliza o
  predicado \codesnippetinline{indent-offset!}. Esse predicado aceita duas
  capturas como argumentos, onde as regras de indentação dos nós capturados
  pela primeira captura serão definidas com base nos deslocamentos dos nós
  capturados pela segunda captura.

  Para ilustrar o uso do predicado \codesnippetinline{indent-offset!},
  tome como referência o seguinte trecho de código em linha:
  \codesnippetinline[rust]{fn foo() {bar()}}. Esse código, escrito na linguagem
  de programação Rust, consiste em uma função concisa. A fim de formatar essa
  função de acordo com a variante \textit{1TBS} do estilo de indentação
  \textit{K\&R} \cite{wiki-2023-indentation}, é possível utilizar a consulta
  mostrada no \cref{snippet:scheme:rust:1tbs-fn}. Nessa consulta,
  \begin{inparaenum}
    \item estão presentes 3 capturas:
          \begin{inparaenum}
            \item \codesnippetinline{item}, que captura qualquer elemento do
                  corpo da função;
            \item \codesnippetinline{close}, que captura o delimitador final do
                  corpo da função; e
            \item \codesnippetinline{fn}, que engloba toda a definição da
                  função.
          \end{inparaenum}
          Dentre essas capturas,
    \item \codesnippetinline{item} tem sua regra de indentação especificada
          como um nível de indentação além do deslocamento do nó pai --- i.e.,
          a própria função ---; e
    \item \codesnippetinline{close} tem sua regra de indentação definida como o
          deslocamento de \codesnippetinline{fn} por meio do uso do predicado
          \codesnippetinline{indent-offset!}. Concluindo, ao final do segundo
          padrão, é utilizado o predicado \codesnippetinline{indent!}, passando
          as respectivas capturas \codesnippetinline{item} e
          \codesnippetinline{close} como argumentos. O resultado da aplicação
          dessa consulta está disponível para verificação no
          \cref{snippet:rust:1tbs-foo}.
  \end{inparaenum}

  \noindent
  \begin{minipage}[t]{\halftextwidthplusfiveempart}
    \begin
      {codesnippet}%
      [scheme]%
      { Consulta para Formatar uma Função em Rust de Acordo Com o Estilo
        \textit{1TBS}}%
      {rust:1tbs-fn}%
      [fontsize=\ABNTEXfontereduzida]
      (#set! indent-style "    ")

      ( (function_item
          body: (block (_) @item "}" @close)) @fn
        (#set! @item indent-rule "+1")
        (#indent-offset! @close @fn)
        (#indent! @item @close))
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{\halftextwidthplusfiveemcounterpart}
    \begin
      {codesnippet}%
      [rust]%
      {Função em Rust Indentada de Acordo Com o Estilo \textit{1TBS}}%
      {1tbs-foo}
      fn foo() {
          bar()
      }
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  %%%%%%%%%%%
  %%% Tests %
  %%%%%%%%%%%

  \section{Testes}
  \label{section:tests}

  Ao final do desenvolvimento do \witchcooking, foi conduzida uma série de
  testes para verificar se o código formatado atendia às expectativas, conforme
  o código e as diretrizes submetidas. Um desses testes envolvia a formatação
  de duas funções aninhadas. O propósito desse teste era averiguar o
  comportamento da formatação em um contexto de aninhamento; ou seja, onde um
  trecho de código sofre o mesmo procedimento de formatação múltiplas vezes,
  mas com base em nós distintos.

  Para realizar esse teste, foram submetidos:
  \begin{inparaenum}
    \item o código-fonte escrito em Rust, que incluía as funções que
          configuravam o aninhamento, ilustrado no
          \cref{snippet:rust:foo-bar-baz}; assim como
    \item as diretrizes de formatação, escritas na linguagem de consulta do
          \treesitter, apresentadas no \cref{snippet:scheme:rust:1tbs-mod}.
  \end{inparaenum}
  A consulta submetida tinha o propósito de dirigir a formatação, de modo que o
  resultado seguisse uma variante do estilo de indentação \textit{1TBS} que
  utiliza 2 espaços em vez dos tradicionais 4 espaços. Assim, o código-fonte
  formatado deveria apresentar a estruturação apresentada no
  \cref{snippet:rust:foo-bar-baz-1tbs}.

  \noindent
  \begin{minipage}[t]{\textwidth}
    \begin
      {codesnippet}%
      [rust]%
      {Funções Aninhadas em Rust}%
      {foo-bar-baz}
      fn foo() {fn bar() {baz()}}
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  \noindent
  \begin{minipage}[t]{\halftextwidthplusfiveempart}
    \begin
      {codesnippet}%
      [scheme]%
      { Consulta para Formatar Funções em Rust de Acordo Com uma Variante do
        Estilo \textit{1TBS}}%
      {rust:1tbs-mod}%
      [fontsize=\ABNTEXfontereduzida]
      (#set! indent-style "  ")

      ( (function_item
          body: (block (_) @item "}" @close)) @fn
        (#set! @item indent-rule "+1")
        (#indent-offset! @close @fn)
        (#indent! @item @close))
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{\halftextwidthplusfiveemcounterpart}
    \begin
      {codesnippet}%
      [rust]%
      {Funções Aninhadas em Rust Conforme a Variante do Estilo \textit{1TBS}}%
      {foo-bar-baz-1tbs}
      fn foo() {
        fn bar() {
          baz()
        }
      }
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  No entanto, ao analisar o resultado da execução do \witchcooking, notou-se um
  código que destoa significativamente das expectativas, conforme apresentado
  no \cref{snippet:rust:foo-bar-baz-bad}. Esse código revela dois problemas
  relevantes. Primeiramente, é evidente que
  \begin{inparaenum}
    \item a indentação não está correta. Isso ocorre porque a expressão de
          função \codesnippetinline[rust]{baz()} possui o mesmo nível de
          indentação que a declaração de função
          \codesnippetinline[rust]$fn bar() {$, a qual engloba a expressão.
          Além disso, e de maior gravidade, percebe-se
    \item a ausência de uma chave que caracterize o fechamento do
          corpo da função \codesnippetinline[rust]$fn foo() {$. Ou seja, a
          formatação de um código sintaticamente correto ocasionou um erro de
          sintaxe.
  \end{inparaenum}

  \noindent
  \begin{minipage}[t]{\textwidth}
    \begin
      {codesnippet}%
      [rust]%
      {Funções Aninhadas Mal Formatadas em Rust}%
      {foo-bar-baz-bad}
      fn foo() {
        fn bar() {
        baz()
      }
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  Para entender as causas de ambos os problemas, é necessário seguir uma
  explicação passo a passo dos procedimentos realizados. Começando pela má
  indentação presente na linha 3 do \cref{snippet:rust:foo-bar-baz-bad}, é
  essencial compreender o funcionamento do segundo padrão da consulta
  submetida, apresentado no \cref{snippet:scheme:rust:1tbs-mod}. Esse padrão,
  que lida com declarações de funções em Rust,
  \begin{inparaenum}
    \item impõe um nível adicional de indentação em relação à função para os
          elementos dentro do corpo da própria função. Além disso, ele
    \item alinha a chave de fechamento do corpo da função com o início da
          própria função.
  \end{inparaenum}

  Durante o processo de busca por correspondências do segundo padrão, realizado
  pelo \treesitter, a primeira função a coincidir com o padrão é função
  \codesnippetinline[rust]{fn bar() {baz()}}. Como posteriormente, no algoritmo
  de formatação do \witchcooking, a aplicação dos predicados ocorre
  sequencialmente conforme a ordem das correspondências, essa função é a
  primeira a ser formatada. Após a aplicação do primeiro procedimento de
  formatação, o código em formatação apresenta a configuração demonstrada no
  \cref{snippet:rust:foo-bar-baz-step-1}.

  \noindent
  \begin{minipage}[t]{\textwidth}
    \begin
      {codesnippet}%
      [rust]%
      {Primeiro Passo da Formatação das Funções Aninhadas em Rust}%
      {foo-bar-baz-step-1}
      fn foo() {fn bar() {
        baz()
                }}
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  Nesse código, destaca-se o deslocamento da expressão de função
  \codesnippetinline[rust]{baz()}, cuja regra de indentação foi especificada
  via \codesnippetinline[scheme]{(#set! @item indent-rule "+1")}, conforme o
  \cref{snippet:scheme:rust:1tbs-mod}. Com base na explicação da
  \cref{section:guidelines}, essa configuração define que o deslocamento da
  expressão de função, capturada via \codesnippetinline{@item}, será calculado
  como a combinação:
  \begin{inparaenum}
    \item do estilo de indentação vigente com
    \item o deslocamento do primeiro caractere não espaço encontrado na linha
          onde começa o nó pai da expressão.
  \end{inparaenum}
  Nesse contexto, o nó pai é o corpo da função \codesnippetinline{bar}, que
  começa na linha 1. Dado que
  \begin{inparaenum}
    \item o primeiro caractere não espaço nessa linha está no início da própria
          linha e
    \item o estilo de indentação vigente é \codesnippetinline{"  "},
  \end{inparaenum}
  a indentação aplicada à expressão de função \codesnippetinline[rust]{baz()}
  configura uma formatação peculiar, como vista no
  \cref{snippet:rust:foo-bar-baz-step-1}.

  Prosseguindo com a compreensão dos procedimentos sucedidos, a segunda função
  a corresponder ao segundo padrão da consulta submetida é a função
  \codesnippetinline{foo}, que engloba todo o código. Similarmente ao ocorrido
  com a função \codesnippetinline{bar}, a aplicação do padrão nessa função
  supostamente resultaria na indentação:
  \begin{inparaenum}
    \item da função \codesnippetinline{bar} e
    \item da chave que fecha o corpo da função \codesnippetinline{foo}.
  \end{inparaenum}
  No entanto, após a execução do segundo procedimento de formatação, o código
  problemático em estudo, apresentado anteriormente no
  \cref{snippet:rust:foo-bar-baz-bad}, é gerado.

  Ao comparar o código resultante do segundo e último procedimento de
  formatação com o código esperado, ilustrado no
  \cref{snippet:rust:foo-bar-baz-1tbs}, observa-se que as duas primeiras linhas
  são idênticas, ou seja, seguem a variante do estilo \textit{1TBS}. No
  entanto, na terceira linha do \cref{snippet:rust:foo-bar-baz-bad}, a
  indentação da expressão da função \codesnippetinline[rust]{baz()} é
  claramente inadequada, pois coincide com a indentação da declaração da função
  que a envolve. Esse problema decorre do cálculo de indentação executado pelo
  predicado \codesnippetinline{indent!}.

  Conforme já explicado, quando é estabelecida uma regra de indentação relativa
  positiva para um nó, o cálculo é baseado:
  \begin{inparaenum}
    \item no deslocamento do primeiro caractere não espaço encontrado na linha
          do pai desse nó, e não
    \item \label{item:parent-offset} no deslocamento do próprio nó pai.
  \end{inparaenum}
  No entanto, o cálculo com base no \cref{item:parent-offset} poderia ser mais
  apropriado, especialmente em circunstâncias de aninhamento. Por exemplo, se
  a indentação fosse calculada conforme o deslocamento do nó pai, ao realizar
  o primeiro procedimento de formatação no \cref{snippet:rust:foo-bar-baz-bad},
  utilizando a mesma consulta do \cref{snippet:scheme:rust:1tbs-mod} como base,
  o resultado seria conforme ilustrado no
  \cref{snippet:rust:foo-bar-baz-step-1-hipo}.

  \noindent
  \begin{minipage}[t]{\halfpart}
    \begin
      {codesnippet}%
      [rust]%
      {Primeiro Passo Hipotético da Formatação das Funções Aninhadas em Rust}%
      {foo-bar-baz-step-1-hipo}
      fn foo() {fn bar() {
                  baz()
                }}
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{\halfpart}
    \begin
      {codesnippet}%
      [rust]%
      {Segundo Passo Hipotético da Formatação das Funções Aninhadas em Rust}%
      {foo-bar-baz-step-2-hipo}
      fn foo() {
        fn bar() {
          baz()
        }
      }
    \end{codesnippet}
    \vspace{-3ex}
    \captionof*{listing}{\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
  \end{minipage}

  Outro ponto passível de aprimoramento é a própria aplicação da indentação,
  que é também realizada pelo predicado \codesnippetinline{indent!}. Esse
  predicado executa a indentação com base somente na linha inicial do nó em
  procedimento. Como resultado, ao aplicar a indentação à função
  \codesnippetinline{bar} no \cref{snippet:rust:foo-bar-baz-step-1}, o conteúdo
  dessa função --- a expressão de função \codesnippetinline[rust]{baz()} ---
  que está em outra linha, permanece inalterado. Contudo, seria mais coerente
  se a indentação ocorresse em bloco, ou seja, o deslocamento seria aplicado
  para cada linha abrangida pelo nó em questão. Com essa melhoria, ao aplicar a
  consulta do \cref{snippet:scheme:rust:1tbs-mod} ao
  \cref{snippet:rust:foo-bar-baz-step-1-hipo}, o resultado seria o conteúdo
  ilustrado no \cref{snippet:rust:foo-bar-baz-step-2-hipo}. Uma vez que esse
  código segue a variante do estilo \textit{1TBS}, o teste teria seu objeto
  cumprido.

  No entanto, ao retomar a análise do código problemático mostrado no
  \cref{snippet:rust:foo-bar-baz-bad}, o comparando com código hipotético
  resultante das melhorias discutidas, observa-se que o código hipotético não
  apresentou um erro de sintaxe decorrente da falta da chave que fecha o corpo
  da função \codesnippetinline{foo}. Isso ocorreu porque, na exemplificação
  dessas possíveis melhorias, não foi considerado o problema que origina a
  omissão da chave em questão. Por sua vez, essa desconsideração ocorreu porque
  esse problema não deriva diretamente do \witchcooking, mas sim de uma
  característica do sistema \treesitter: ao sincronizar um nó, as edições
  ocorridas tangentes à sua extensão não são contabilizadas.

  Para compreender a complexidade envolvida nesse problema, é essencial
  entender minimamente o funcionamento do processo de formatação; mais
  especificamente, como o processo de edição do código em formatação opera.
  Conforme mencionado na \cref{section:fmt-algorithm}, o algoritmo de
  formatação é composto, entre outros componentes, por uma estrutura editora.
  Essa estrutura retém o código-fonte em formatação e registra as edições (ou
  modificações) realizadas pelos predicados.

  Para realizar as edições, um predicado sempre se baseia em ao menos um nó.
  Dentre as informações que um nó possui, está a extensão de caracteres que o
  configura no código-fonte. Essa extensão compreende um início e um fim
  representados em ambos os níveis:
  \begin{inparaenum}
    \item de bytes, especificando o deslocamento dentre os bytes do
          código-fonte; bem como
    \item de pontos, onde cada ponto refere-se a uma linha e uma coluna
          específica.
  \end{inparaenum}
  Originalmente, os nós capturados nos padrões mantêm as extensões conforme
  presentes no código-fonte submetido. Portanto, ao manipulá-los, os
  predicados devem sincronizar os nós para que suas extensões estejam
  consoantes ao código vigente em processo de formatação.

  Como demonstrado no \cref{appendix:node-edit-demo}, ao sincronizar um nó, o
  \treesitter não contabiliza edições tangentes à extensão desse nó.
  Consequentemente, especialmente em cenários que apresentam estruturas
  aninhadas, durante o processo de formatação, ao sincronizar um nó, há uma
  probabilidade considerável de que ele apresente uma extensão corrompida. Não
  surpreendentemente, essa é a razão por trás da omissão da chave, conforme
  demonstrada no \cref{snippet:rust:foo-bar-baz-bad}. Essa chave --- que foi
  capturada via \codesnippetinline{@close} --- tem sua regra de indentação
  definida como o deslocamento da função \codesnippetinline{foo}, como mostra o
  seguinte fragmento em linha do \cref{snippet:scheme:rust:1tbs-mod}:
  \codesnippetinline[scheme]{(#indent-offset! @close @fn)}. Para indentá-la,
  mais especificamente, para aplicar os caracteres que configuram sua
  indentação, o predicado \codesnippetinline{indent!} busca um nó irmão que
  preceda a chave. Esse nó, por sua vez, é a função \codesnippetinline{bar}, a
  qual já fora modificada nos procedimentos anteriores. Como resultado, o
  predicado considera a extensão corrompida dessa função e, consequentemente,
  aplica a indentação que sobrescreve a chave que fecha o corpo da função
  \codesnippetinline{bar}.

  %%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Discussion of Results %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%

  \section{Discussão dos Resultados}

  Conforme demonstrado ao longo deste capítulo, o algoritmo desenvolvido,
  fundamentado no \treesitter, permite a formatação --- multilíngue e
  personalizada --- de código-fonte via as implementações que estendem a
  linguagem de consulta do sistema. Mais especificamente, em adição à base
  fornecida pelo \treesitter, a formatação é proporcionada pelas:
  \begin{inparaenum}
    \item configurações, sendo elas
          \begin{inparaenum}
            \item \codesnippetinline{indent-rule} e
            \item \codesnippetinline{indent-style};
          \end{inparaenum}
          em conjunto com
    \item os predicados, sendo eles
          \begin{inparaenum}
            \item \codesnippetinline{space!},
            \item \codesnippetinline{indent!}, e
            \item \codesnippetinline{indent-offset!}.
          \end{inparaenum}
  \end{inparaenum}

  Como explicado e demonstrado na \cref{section:guidelines}, é possível
  desempenhar procedimentos básicos de formatação através do \witchcooking. Nos
  exemplos utilizados, é perceptível que o código-fonte submetido para
  formatação já possui uma organização razoável. Ou seja, a ferramenta foi
  utilizada para realizar operações pontuais de formatação.

  Contudo, na \cref{section:tests}, a partir de um cenário mais complexo de
  formatação, foi apresentado um mau funcionamento na sincronização das
  extensões dos nós. Conforme reportado, essa falha, que deriva de uma
  característica peculiar do \treesitter, compromete o uso da ferramenta para
  efetuar procedimentos de formatação mais robustos. Portanto, ao considerar
  cenários mais realistas, nos quais não é possível presumir algo sobre a
  estruturação inicial do código, não é prudente pressupor que consultas mais
  complexas sejam capazes de abranger esses cenários sem ocasionar erros de
  sintaxe.

  Concluindo, ainda na \cref{section:tests}, a partir da exemplificação do
  predicado \codesnippetinline{indent!}, foram discutidos:
  \begin{inparaenum}
    \item as limitações desse predicado ao aplicar diferentes regras de
          indentação, além de
    \item possíveis melhorias para tornar essas aplicações mais coerentes,
          sobretudo ao indentar nós que abrangem múltiplas linhas.
  \end{inparaenum}

  %%%%%%%%%%%%%%%
  %% Conclusion %
  %%%%%%%%%%%%%%%

  \chapter{Conclusão}

  A partir da implementação
  \begin{inparaenum}
    \item do algoritmo de formatação fundamentado no \treesitter, descrito na
          \cref{section:fmt-algorithm};
    \item das configurações de estilização para o predicado
          \codesnippetinline{set!}, descritas na \cref{section:guidelines},
          sendo elas
          \begin{inparaenum}
            \item \codesnippetinline{indent-rule} e
            \item \codesnippetinline{indent-style};
          \end{inparaenum}
          e
    \item dos predicados basais para a formatação, estendendo a linguagem de
          consulta, demonstrados também na \cref{section:guidelines}, sendo
          eles
          \begin{inparaenum}
            \item \codesnippetinline{space!},
            \item \codesnippetinline{indent!}, e
            \item \codesnippetinline{indent-offset!};
          \end{inparaenum}
  \end{inparaenum}
  foi possível atender ao objetivo geral deste trabalho: desenvolver o
  \witchcooking \cite{silva-2023-witch}.

  Assim, conforme demonstrado ao longo do \cref{chapter:witch}, o software
  desenvolvido com base no sistema \treesitter atendeu
  aos objetivos de:
  \begin{inparaenum}
    \item \label{item:embrace} abranger uma gama de linguagens de programação%
          \footnote
            { Mais especificamente, o \witchcooking suporta as seguintes
              linguagens:
              \begin{inparaenum}[(I)]
                \item Bash,
                \item C,
                \item C++,
                \item Go,
                \item HTML,
                \item Java,
                \item JavaScript,
                \item Python,
                \item Rust e
                \item TOML.
              \end{inparaenum}}
          e
    \item \label{item:custom} proporcionar a formatação personalizada via a
          linguagem de consulta do sistema.
  \end{inparaenum}
  A respeito do \cref{item:embrace}, a ferramenta tem potencial de suportar
  qualquer linguagem que tenha uma gramática compatível com a versão do
  \treesitter utilizada no \witchcooking. No entanto, quanto ao
  \cref{item:custom}, é importante ressaltar que a ferramenta desenvolvida não
  é funcional para cenários realistas, uma vez que muito provavelmente
  ocasionará erros de sintaxe.

  Esses erros de sintaxe que podem ocorrer --- principalmente em cenários mais
  complexos de formatação --- derivam de uma característica da edição (ou
  sincronização) de nós feita pelo \treesitter: ao sincronizar um nó, as
  edições ocorridas tangentes à sua extensão não são contabilizadas. Essa
  peculiaridade --- demonstrada no \cref{appendix:node-edit-demo} --- só foi
  identificada durante os testes realizados para validar o funcionamento das
  configurações e dos predicados desenvolvidos. Essa descoberta tardia
  dificilmente poderia ser antecipada, uma vez que esse comportamento da
  sincronização não é mencionado na documentação do método
  \codesnippetinline{edit} \cite{tree-sitter-2023-node}.

  %%%%%%%%%%%%%%%%%%%
  %%% Contributions %
  %%%%%%%%%%%%%%%%%%%

  \section{Contribuições}

  A proposta de desenvolver um algoritmo multilíngue para a formatação de
  código-fonte não é inédita nem recente. Por exemplo, como mencionado no
  \cref{chapter:src-fmt}, já na década de 80,
  \textcite{oppen-1980-prettyprinting} descreveu seu algoritmo de formatação
  baseado em anotações. Contudo, o \witchcooking apresenta uma nova abordagem
  de formatação multilíngue: via o \treesitter e sua linguagem de consulta.

  Diferentemente do algoritmo de Oppen que
  \begin{inparaenum}
    \item depende de um terceiro para fornecer o código com as anotações
          necessárias, e
    \item formata conforme o \textit{CPL} em adição às anotações fornecidas;
  \end{inparaenum}
  o \witchcooking
  \begin{inparaenum}
    \item alcança a formatação multilíngue através do \treesitter, e
    \item proporciona predicados para dirigir a formatação.
  \end{inparaenum}
  Ao comparar essas duas abordagens, observa-se que o \witchcooking oferece
  maior controle ao usuário, embora exija dele um conhecimento considerável:
  \begin{inparaenum}
    \item da sintaxe em questão e
    \item da linguagem de consulta.
  \end{inparaenum}

  Quanto às diretrizes de formatação, especificamente no que se refere à
  utilização das configurações em conjunto com os predicados, assemelha-se
  bastante ao que \textcite{yelland-2015-new} denomina de \textit{combinators}
  --- funções geradoras para descrever layouts alternativos de código-fonte ---
  presentes em seu formatador de código-fonte para a linguagem R. Mais
  precisamente:
  \begin{inparaenum}
    \item o predicado \codesnippetinline{space!} opera similarmente ao
          \textit{combinator}
          \codesnippetinline{|$\leftrightarrow$|}[escapeinside=||] --- que lida
          com a colocação horizontal ---, enquanto
    \item o predicado \codesnippetinline{indent!} funciona análogo ao uso de
          \codesnippetinline{|$\leftrightarrow$|}[escapeinside=||] em conjunto
          com o \textit{combinator}
          \codesnippetinline{|$\updownarrow$|}[escapeinside=||] --- que
          controla a colocação vertical.
  \end{inparaenum}
  Uma diferença significativa entre essas duas abordagens reside no fato de
  que: enquanto
  \begin{inparaenum}
    \item os \textit{combinators} se limitam ao algoritmo de formatação,
    \item os predicados são disponibilizados ao usuário --- por meio da
          linguagem de consulta do \treesitter{} ---, permitindo que ele
          componha suas próprias diretrizes de formatação.
  \end{inparaenum}

  %%%%%%%%%%%%%%%%%%
  %%% Future Works %
  %%%%%%%%%%%%%%%%%%

  \section{Trabalhos Futuros}

  Como enfatizado diversas vezes durante este trabalho, o \witchcooking é uma
  ferramenta prototípica para formatação de código-fonte. Consequentemente, há
  vários aspectos com potencial de aprimoramento.
  \begin{inparaenum}
    \item O problema mais premente é a sincronização de nós --- abordado na
          \cref{section:tests} ---, para o qual seria possível desenvolver um
          algoritmo dedicado capaz de sincronizar corretamente qualquer nó
          mesmo após ele ter sofrido edições tangentes à sua extensão.

          Outras melhorias potenciais, também discutidas na
          \cref{section:tests}, estão relacionadas ao funcionamento do
          predicado \codesnippetinline{indent!}. Nesse contexto, é possível
          aprimorar
    \item a formatação de nós com regras de indentação relativa positiva, de
          modo que a indentação siga o deslocamento do nó pai, em vez de se
          basear no primeiro caractere não espaço encontrado na linha do pai.
          Além disso,
    \item seria mais coerente que esse predicado indentasse o bloco inteiro ao
          qual o nó se estende, em vez de se limitar à linha inicial do nó em
          questão.

    \item Aprimoramentos relacionados ao dinamismo da formatação, como
          \begin{inparaenum}
            \item a formatação com base no \textit{CPL} e
            \item a otimização para determinar o melhor layout,
          \end{inparaenum}
          também seriam extremamente benéficos. Esse grau de sofisticação é
          comum em formatadores modernos de código-fonte. No entanto, uma
          análise mais aprofundada seria necessária para determinar a
          viabilidade dessas implementações sofisticadas, considerando a
          natureza do \witchcooking.

          Final e adicionalmente,
    \item seria bastante útil a disponibilização de
          diretrizes de formatação que sigam os estilos de formatação
          convencionais para as linguagens de programação mais populares
          (a princípio). Dessa forma, o usuário poderia utilizar essas
          diretrizes providas como base para suas personalizações.
  \end{inparaenum}

  %%%%%%%%%%%%%%%%%%%%%%%%%
  % Post Textual Elements %
  %%%%%%%%%%%%%%%%%%%%%%%%%

  \postextual
  \printbibliography
  \printgloss{glossary}

  %%%%%%%%%%%%%%%
  %% Appendices %
  %%%%%%%%%%%%%%%

  \begin{apendicesenv}
    \partapendices

    %%%%%%%%%%%%%%%%%%
    % Making Queries %
    %%%%%%%%%%%%%%%%%%

    \chapter{Fazendo Consultas}
    \label{appendix:queries}

    Como mencionado na \cref{section:usage}, o \witchcooking formata o
    código-fonte conforme as diretrizes presentes no arquivo submetido via
    \codesnippetinline{-q QUERY}, o qual é escrito na linguagem de consulta do
    \treesitter. Devido à importância fundamental desempenhada por essa
    linguagem na ferramenta, é essencial possuir um conhecimento básico sobre o
    seu funcionamento. Portanto, nesta seção, será abordado superficialmente o
    funcionamento da linguagem de consulta do \treesitter, permitindo assim uma
    melhor compreensão da base em que o \witchcooking foi desenvolvido.

    Como abordado no \cref{chapter:tree-sitter}, a linguagem de consulta do
    \treesitter foi originalmente concebida para buscar padrões na árvore
    sintática via:
    \begin{inparaenum}
      \item definição de padrões de correspondência e
      \item aplicação de predicados.
    \end{inparaenum}
    Os predicados disponibilizados nativamente pelo \treesitter são agnósticos
    quanto à linguagem de programação utilizada. Por outro lado, os padrões de
    correspondência variam de acordo com a linguagem devido às suas construções
    gramaticais específicas, que são posteriormente traduzidas como nós na
    árvore de sintaxe analisada.

    Por exemplo, considere os \cref{snippet:c:add-two,snippet:rust:add-two},
    escritos nas linguagens de programação C e Rust, respectivamente. Embora
    ambos desempenhem papéis idênticos --- i.e., definem uma função que retorna
    a soma do parâmetro \codesnippetinline{x} com 2 ---, suas árvores de
    sintaxe analisadas --- apresentadas respectivamente nos
    \cref{snippet:text:tree:c:add-two,snippet:text:tree:rust:add-two} ---
    exibem diferenças significativas. Portanto, para buscar a correspondência
    do trecho em que o parâmetro \textit{x} é definido em ambos os códigos ---
    i.e.,
    \codesnippetinline
      [c]
      $int add_two(|\colorbox{codehighlight}{int x}|) {$
      [escapeinside=||]
    e
    \codesnippetinline
      [rust]
      $fn add_two(|\colorbox{codehighlight}{x: i32}|) -> i32 {$
      [escapeinside=||]
    ---, são necessárias consultas distintas, apresentadas pelos
    \cref{snippet:scheme:c:param-query,snippet:scheme:rust:param-query}.

    Dado que os padrões correspondem a qualquer uma de suas ocorrências, é
    importante garantir maior especificidade em sua definição. Isso pode ser
    obtido por meio de:
    \begin{inparaenum}
      \item especificação de campos,
      \item especificação de nós anônimos e
      \item aplicação de predicados.
    \end{inparaenum}
    Para ilustrar, ao aplicar a consulta apresentada no
    \cref{snippet:scheme:c:param-query} ao seguinte código em linha
    \codesnippetinline[c]{int add(int x, int y);}, obtêm-se duas
    correspondências, como destacadas no seguinte trecho:
    \codesnippetinline[c]{int add(|\hi{int x}, \hi{int y}|);}[escapeinside=||].
    Logo, para corresponder somente ao parâmetro \codesnippetinline{x}, deve-se
    utilizar uma consulta mais elaborada, conforme exemplificada no
    \cref{snippet:scheme:c:x-param-query}. Nesse trecho, é possível notar
    algumas diferenças em relação à sua versão original, que foi apresentada no
    \cref{snippet:scheme:c:param-query}.
    \begin{inparaenum}
      \item O nó \codesnippetinline{(identifier)} é capturado com o nome
            \codesnippetinline{id}, como destacado no seguinte trecho de
            código:
            \codesnippetinline
              [scheme]
              {declarator: |\hi{(identifier) @id}|}
              [escapeinside=||]%
            . Além disso,
      \item o predicado \codesnippetinline{eq?} é aplicado para garantir que o
            conteúdo da captura \codesnippetinline{id} corresponda à string
            ``x'' o que, por consequência, impede a correspondência do
            parâmetro \codesnippetinline{y}.
    \end{inparaenum}

    Por fim, é importante ressaltar que a linguagem de consulta do \treesitter
    disponibiliza recursos adicionais \cite{tree-sitter-2023-using} que vão
    além do escopo desta seção. No entanto, as informações abordadas até então
    estabelecem uma base fundamental para compreender o funcionamento da
    linguagem de consulta e sua aplicação em conjunto com o \witchcooking na
    formatação do código-fonte.

    \noindent
    \begin{minipage}[t]{\halfpart}
      \begin
        {codesnippet}%
        [c]%
        {Função \textit{add\_two} em C}%
        {add-two}
        int add_two(int x) {
          return x + 2;
        }
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        {\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{\halfpart}
      \begin
        {codesnippet}%
        [rust]%
        {Função \textit{add\_two} em Rust}%
        {add-two}
        fn add_two(x: i32) -> i32 {
          x + 2
        }
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        {\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
    \end{minipage}

    \noindent
    \begin{minipage}[t]{\halftextwidthpart}
      \begin
        {codesnippet}*%
        {Árvore Sintática da Função \textit{add\_two} em C}%
        {tree:c:add-two}%
        [fontsize=\ABNTEXfontereduzida]
        function_definition
          type: primitive_type
          declarator: function_declarator
            declarator: identifier
            parameters: parameter_list
              parameter_declaration
                type: primitive_type
                declarator: identifier
          body: compound_statement
            return_statement
              binary_expression
                left: identifier
                right: number_literal
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        { \ABNTEXfontereduzida
          \textbf{Fonte:} o próprio autor.
          \\
          \textbf{Nota:} Nós anônimos foram omitidos.}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{\halftextwidthcounterpart}
      \begin
        {codesnippet}*%
        {Árvore Sintática da Função \textit{add\_two} em Rust}%
        {tree:rust:add-two}%
        [fontsize=\ABNTEXfontereduzida]
        function_item
          name: identifier
          parameters: parameters
            parameter
              pattern: identifier
              type: primitive_type
          return_type: primitive_type
          body: block
            binary_expression
              left: identifier
              right: integer_literal
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        { \ABNTEXfontereduzida
          \textbf{Fonte:} o próprio autor.
          \\
          \textbf{Nota:} Nós anônimos foram omitidos.}
    \end{minipage}

    \noindent
    \begin{minipage}[t]{\halftextwidthpart}
      \begin
        {codesnippet}*%
        [scheme]%
        {Consulta Correspondendo a um Parâmetro de Função em C}%
        {c:param-query}
        (parameter_declaration
          type: (primitive_type)
          declarator: (identifier))
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        {\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{\halftextwidthcounterpart}
      \begin
        {codesnippet}*%
        [scheme]%
        {Consulta Correspondendo a um Parâmetro de Função em Rust}%
        {rust:param-query}
        (parameter
          pattern: (identifier)
          type: (primitive_type))
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        {\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
    \end{minipage}

    \noindent
    \begin{minipage}[t]{\textwidth}
      \begin
        {codesnippet}*%
        [scheme]%
        {Consulta Correspondendo a um Parâmetro \textit{x} de uma Função em C}%
        {c:x-param-query}
        (parameter_declaration
          type: (primitive_type)
          declarator: (identifier) @id
          (#eq? @id "x"))
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        {\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
    \end{minipage}

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Tree-Sitter's Node Syncing %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \chapter{Sincronizando Nós do \treesitter}
    \label{appendix:node-edit-demo}

    Na \cref{section:tests}, foi mencionado que, ao sincronizar um nó, o
    sistema \treesitter não contabiliza as edições ocorridas que tangem a
    extensão desse nó. Este apêndice tem como objetivo demonstrar esse
    comportamento de forma didática. Para reproduzí-lo, é necessário:
    \begin{inparaenum}
      \item Rust \cite{rust-2023-rust}, a linguagem de programação;
      \item \textit{Cargo} \cite{rust-2023-cargo}, o gerenciador de pacotes
            dessa linguagem; além das bibliotecas
      \item \textit{tree-sitter} e
      \item \textit{tree-sitter-rust}.
    \end{inparaenum}

    Primeiramente, para criar um novo projeto, é possível executar o seguinte
    comando: \codesnippetinline[sh]{cargo new ts-node-edit}. Esse comando cria
    um novo pacote executável \textit{Cargo}, nomeado de
    \codesnippetinline{ts-node-edit}, que será usado para realizar os
    procedimentos dessa demonstração. Em seguida, para navegar ao diretório
    recém-criado, com o mesmo nome do projeto, pode ser executado o seguinte
    comando: \codesnippetinline[sh]{cd ts-node-edit}. Dentro desse diretório,
    para adicionar as dependências --- i.e., as bibliotecas --- necessárias, é
    possível executar o seguinte comando em linha:
    \codesnippetinline[sh]{cargo add tree-sitter{,-rust}}. Após a execução
    desses comandos, a configuração inicial é concluída.

    Para escrever o código, é necessário editar o arquivo localizado no
    seguinte caminho: \codesnippetinline{src/main.rs}. A seguir, serão
    mostrados e explicados os trechos de código que compõem esse arquivo. Essa
    abordagem fragmentada foi adotada por dois motivos principais:
    \begin{inparaenum}
      \item explicar os procedimentos na ordem de execução, e
      \item evitar problemas de formatação neste documento.
    \end{inparaenum}

    Conforme ilustrado no \cref{snippet:rust:ts-node-edit-demo-part-1},
    primeiramente,
    \begin{inparaenum}
      \item são importados alguns itens da biblioteca \treesitter que são
            utilizados nessa demonstração. Em seguida,
      \item inicia-se a função principal, que engloba todos os procedimentos.
            Dentro dessa função, inicialmente,
      \item é definido a string do código-fonte usado como referência na
            demonstração: \codesnippetinline[rust]{fn foo() {}}. Além disso,
            nas próximas linhas,
      \item são realizados procedimentos para gerar a árvore de sintaxe a
            partir da análise do código-fonte definido anteriormente.
    \end{inparaenum}

    Continuando, no \cref{snippet:rust:ts-node-edit-demo-part-2}, observa-se
    que: primeiramente,
    \begin{inparaenum}
      \item é obtido um nó que supostamente remete à função
            \codesnippetinline{foo}. Logo na sequência,
      \item essa suposição é validada por uma asserção. Já nas linhas
            subsequentes,
      \item são realizados procedimentos similares, porém buscando o nó que
            representa o nome da função.
    \end{inparaenum}
    Em seguida, nos
    \cref
      {%
        snippet:rust:ts-node-edit-demo-part-3,%
        snippet:rust:ts-node-edit-demo-part-4}%
    , são executadas duas asserções semelhantes. Essas asserções verificam os
    valores originais das extensões --- tanto em bytes quanto em pontos --- dos
    nós:
    \begin{inparaenum}
      \item da função \codesnippetinline{foo} e
      \item do seu nome.
    \end{inparaenum}

    Uma vez que, antes de qualquer modificação ocorrer, foram avaliadas as
    extensões de ambos os nós, ou seja,
    \begin{inparaenum}
      \item da função \codesnippetinline{foo} e
      \item do seu nome,
    \end{inparaenum}
    é possível mensurar o efeito da sincronização de uma edição para cada um
    deles. Para isso, é definida a edição ilustrada no
    \cref{snippet:rust:ts-node-edit-demo-part-5}. Essa edição simula a inserção
    do caractere de quebra de linha imediatamente após a palavra-chave
    \codesnippetinline[rust]{fn} em: \codesnippetinline[rust]{fn foo() {}}.
    É importante ressaltar que essa edição acontece:
    \begin{inparaenum}
      \item antes do nome da função \codesnippetinline{foo}, bem como
      \item dentro dessa função.
    \end{inparaenum}

    Prosseguindo, conforme o \cref{snippet:rust:ts-node-edit-demo-part-6}, o
    nó que representa nome da função \codesnippetinline{foo} é sincronizado
    com a edição que simula a inserção da quebra de linha, mencionada
    anteriormente. Em seguida, ainda nesse trecho, uma asserção é executada
    para confirmar que a extensão desse nó refletiu essa edição. Já no trecho
    \ref{snippet:rust:ts-node-edit-demo-part-7}, finalizando o código, os
    mesmos procedimentos do trecho anterior são repetidos, com exceção de que:
    \begin{inparaenum}
      \item o nó sincronizado dessa vez é o nó que representa a própria função
            e
      \item a asserção feita verifica que esse nó não sofreu modificação em sua
            extensão.
    \end{inparaenum}

    Concluindo, para executar o projeto e constatar os resultados, é possível
    executar o comando: \codesnippetinline[sh]{cargo run}. Ao fazê-lo,
    é constatável que o \textit{\gloss{exit-status}} retornado é zero, ou
    seja, a execução foi bem-sucedida. Isso implica que todas as asserções
    feitas no código eram verdadeiras. Por sua vez, as asserções feitas nos
    \cref
      {%
        snippet:rust:ts-node-edit-demo-part-6,%
        snippet:rust:ts-node-edit-demo-part-7}
    provaram que, com base na edição ilustrada no
    \cref{snippet:rust:ts-node-edit-demo-part-5}:
    \begin{inparaenum}
      \item ao sincronizar o nó representando o nome da função, localizado
            após a extensão da edição feita, o nó apresentou a extensão
            esperada, assim, refletindo a edição; já
      \item ao sincronizar o nó remetendo à própria função, cuja extensão
            englobava a edição feita, esse nó não apresentou alguma modificação
            em sua extensão, fatalmente, não refletindo a edição feita.
    \end{inparaenum}

    \noindent
    \begin{minipage}[t]{\textwidth}
      \begin
        {codesnippet}%
        [rust]%
        {Demonstração da Sincronização de Nós do \treesitter em Rust Parte 1}%
        {ts-node-edit-demo-part-1}
        use tree_sitter::{InputEdit, Parser, Point, Range};

        fn main() {
          let src = "fn foo() {}";
          let mut parser = Parser::new();
          parser.set_language(tree_sitter_rust::language()).unwrap();
          let tree = parser.parse(src, None).unwrap();
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        {\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
    \end{minipage}

    \noindent
    \begin{minipage}[t]{\textwidth}
      \begin
        {codesnippet}*%
        [rust]%
        {Demonstração da Sincronização de Nós do \treesitter em Rust Parte 2}%
        {ts-node-edit-demo-part-2}%
        [autogobble=false,firstnumber=last,gobble=8,lastline=5]
          let mut fn_item = tree.root_node().child(0).unwrap();
          assert_eq!("function_item", fn_item.kind());
          let mut fn_name =
            fn_item.child_by_field_name("name").unwrap();
          assert_eq!("identifier", fn_name.kind());
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        {\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
    \end{minipage}

    \noindent
    \begin{minipage}[t]{\textwidth}
      \begin
        {codesnippet}*%
        [rust]%
        {Demonstração da Sincronização de Nós do \treesitter em Rust Parte 3}%
        {ts-node-edit-demo-part-3}%
        [autogobble=false,firstnumber=last,gobble=8,lastline=9]
          assert_eq!(
            Range {
              start_byte: 0,
              end_byte: 11,
              start_point: Point { row: 0, column: 0 },
              end_point: Point { row: 0, column: 11 },
            },
            fn_item.range(),
          );
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        {\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
    \end{minipage}

    \noindent
    \begin{minipage}[t]{\textwidth}
      \begin
        {codesnippet}*%
        [rust]%
        {Demonstração da Sincronização de Nós do \treesitter em Rust Parte 4}%
        {ts-node-edit-demo-part-4}%
        [autogobble=false,firstnumber=last,gobble=8,lastline=9]
          assert_eq!(
            Range {
              start_byte: 3,
              end_byte: 6,
              start_point: Point { row: 0, column: 3 },
              end_point: Point { row: 0, column: 6 },
            },
            fn_name.range(),
          );
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        {\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
    \end{minipage}

    \noindent
    \begin{minipage}[t]{\textwidth}
      \begin
        {codesnippet}*%
        [rust]%
        {Demonstração da Sincronização de Nós do \treesitter em Rust Parte 5}%
        {ts-node-edit-demo-part-5}%
        [autogobble=false,firstnumber=last,gobble=8,lastline=8]
          let nl_edit = InputEdit {
            start_byte: 2,
            old_end_byte: 2,
            new_end_byte: 3,
            start_position: Point { row: 0, column: 2 },
            old_end_position: Point { row: 0, column: 2 },
            new_end_position: Point { row: 1, column: 0 },
          };
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        {\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
    \end{minipage}

    \noindent
    \begin{minipage}[t]{\textwidth}
      \begin
        {codesnippet}*%
        [rust]%
        {Demonstração da Sincronização de Nós do \treesitter em Rust Parte 6}%
        {ts-node-edit-demo-part-6}%
        [autogobble=false,firstnumber=last,gobble=8,lastline=10]
          fn_name.edit(&nl_edit);
          assert_eq!(
            Range {
              start_byte: 4,
              end_byte: 7,
              start_point: Point { row: 1, column: 1 },
              end_point: Point { row: 1, column: 4 },
            },
            fn_name.range(),
          );
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        {\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
    \end{minipage}

    \noindent
    \begin{minipage}[t]{\textwidth}
      \begin
        {codesnippet}*%
        [rust]%
        {Demonstração da Sincronização de Nós do \treesitter em Rust Parte 7}%
        {ts-node-edit-demo-part-7}%
        [autogobble=false,firstnumber=last,gobble=8,lastline=11]
          fn_item.edit(&nl_edit);
          assert_eq!(
            Range {
              start_byte: 0,
              end_byte: 11,
              start_point: Point { row: 0, column: 0 },
              end_point: Point { row: 0, column: 11 },
            },
            fn_item.range(),
          );
        }
      \end{codesnippet}
      \vspace{-3ex}
      \captionof*
        {listing}
        {\ABNTEXfontereduzida \textbf{Fonte:} o próprio autor.}
    \end{minipage}
  \end{apendicesenv}
\end{document}